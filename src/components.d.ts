/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { IRatePlanSelection, RatePlanGuest } from "./stores/booking.store";
import { ICurrency } from "./models/calendarData";
import { ICountry, IEntries, RoomBlockDetails } from "./models/IBooking";
import { TAdultChildConstraints, TIglBookPropertyPayload } from "./models/igl-book-property.d";
import { IToast } from "./components/ui/ir-toast/toast";
import { IglBookPropertyPayloadEditBooking, TAdultChildConstraints as TAdultChildConstraints1, TPropertyButtonsTypes, TSourceOptions } from "./models/igl-book-property";
import { CalendarModalEvent, IRoomNightsData, IRoomNightsDataEventPayload } from "./models/property-types";
import { IPageTwoDataUpdateProps } from "./models/models";
import { RatePlan, RoomType } from "./models/property";
import { CalendarSidebarState } from "./components/igloo-calendar/igloo-calendar";
import { IToast as IToast1, TPositions } from "./components/ui/ir-toast/toast";
import { Booking, ExtraService, IBookingPickupInfo, IOtaNotes, OtaService, Room, SharedPerson } from "./models/booking.dto";
import { OpenSidebarEvent } from "./components/ir-booking-details/types";
import { TIcons } from "./components/ui/ir-icons/icons";
import { checkboxes, selectOption } from "./common/models";
import { ComboboxItem } from "./components/ui/ir-combobox/ir-combobox";
import { ICountry as ICountry1, IToast as IToast2 } from "./components.d";
import { IHouseKeepers, Task, THKUser } from "./models/housekeeping";
import { FactoryArg } from "imask";
import { ZodType } from "zod";
import { PaymentOption } from "./models/payment-options";
import { IPaymentAction } from "./services/payment.service";
import { Moment } from "moment";
import { SalesFilters } from "./components/ir-sales-by-country/ir-sales-filters/types";
import { SalesRecord } from "./components/ir-sales-by-country/ir-sales-table/ir-sales-table";
import { TaskFilters } from "./components/ir-housekeeping/ir-hk-tasks/types";
import { ToolbarConfig } from "./components/ui/ir-text-editor/ir-text-editor";
import { User } from "./models/Users";
import { AllowedUser } from "./components/ir-user-management/types";
export { IRatePlanSelection, RatePlanGuest } from "./stores/booking.store";
export { ICurrency } from "./models/calendarData";
export { ICountry, IEntries, RoomBlockDetails } from "./models/IBooking";
export { TAdultChildConstraints, TIglBookPropertyPayload } from "./models/igl-book-property.d";
export { IToast } from "./components/ui/ir-toast/toast";
export { IglBookPropertyPayloadEditBooking, TAdultChildConstraints as TAdultChildConstraints1, TPropertyButtonsTypes, TSourceOptions } from "./models/igl-book-property";
export { CalendarModalEvent, IRoomNightsData, IRoomNightsDataEventPayload } from "./models/property-types";
export { IPageTwoDataUpdateProps } from "./models/models";
export { RatePlan, RoomType } from "./models/property";
export { CalendarSidebarState } from "./components/igloo-calendar/igloo-calendar";
export { IToast as IToast1, TPositions } from "./components/ui/ir-toast/toast";
export { Booking, ExtraService, IBookingPickupInfo, IOtaNotes, OtaService, Room, SharedPerson } from "./models/booking.dto";
export { OpenSidebarEvent } from "./components/ir-booking-details/types";
export { TIcons } from "./components/ui/ir-icons/icons";
export { checkboxes, selectOption } from "./common/models";
export { ComboboxItem } from "./components/ui/ir-combobox/ir-combobox";
export { ICountry as ICountry1, IToast as IToast2 } from "./components.d";
export { IHouseKeepers, Task, THKUser } from "./models/housekeeping";
export { FactoryArg } from "imask";
export { ZodType } from "zod";
export { PaymentOption } from "./models/payment-options";
export { IPaymentAction } from "./services/payment.service";
export { Moment } from "moment";
export { SalesFilters } from "./components/ir-sales-by-country/ir-sales-filters/types";
export { SalesRecord } from "./components/ir-sales-by-country/ir-sales-table/ir-sales-table";
export { TaskFilters } from "./components/ir-housekeeping/ir-hk-tasks/types";
export { ToolbarConfig } from "./components/ui/ir-text-editor/ir-text-editor";
export { User } from "./models/Users";
export { AllowedUser } from "./components/ir-user-management/types";
export namespace Components {
    interface IglApplicationInfo {
        "baseData": { unit: { id: string; name: string }; roomtypeId: number };
        "bedPreferenceType": any[];
        "bookingType": string;
        "currency": ICurrency;
        "guestInfo": RatePlanGuest | null;
        "rateplanSelection": IRatePlanSelection;
        "roomIndex": number;
        "totalNights": number;
    }
    interface IglBlockDatesView {
        "defaultData": { [key: string]: any };
        "entryDate": string;
        "entryHour": number;
        "entryMinute": number;
        "fromDate": string;
        "isEventHover": boolean;
        "toDate": string;
    }
    interface IglBookProperty {
        "adultChildConstraints": TAdultChildConstraints;
        "allowedBookingSources": any;
        "bookingData": { [key: string]: any };
        "countries": ICountry[];
        "currency": ICurrency;
        "language": string;
        "propertyid": number;
        "showPaymentDetails": boolean;
    }
    interface IglBookPropertyContainer {
        "from_date": string;
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
        "to_date": string;
        "withIrToastAndInterceptor": boolean;
    }
    interface IglBookPropertyFooter {
        "dateRangeData": { [key: string]: any };
        "disabled": boolean;
        "eventType": string;
        "isEditOrAddRoomEvent": boolean;
        "isLoading": string;
        "page": string;
    }
    interface IglBookPropertyHeader {
        "adultChildConstraints": TAdultChildConstraints1;
        "adultChildCount": { adult: number; child: number };
        "bookedByInfoData": any;
        "bookingData": any;
        "bookingDataDefaultDateRange": { [key: string]: any };
        "dateRangeData": any;
        "defaultDaterange": { from_date: string; to_date: string };
        "message": string;
        "minDate": string;
        "propertyId": number;
        "showSplitBookingOption": boolean;
        "sourceOptions": TSourceOptions[];
        "splitBookingId": any;
        "splitBookings": any[];
        "wasBlockedUnit": boolean;
    }
    interface IglBookingEvent {
        "allBookingEvents": { [key: string]: any };
        "bookingEvent": { [key: string]: any };
        "countries": ICountry[];
        "currency": any;
        "is_vacation_rental": boolean;
        "language": string;
    }
    interface IglBookingEventHover {
        "bookingEvent": { [key: string]: any };
        "bubbleInfoTop": boolean;
        "countries": ICountry[];
        "currency": any;
        "is_vacation_rental": boolean;
    }
    interface IglBookingForm {
        "bedPreferenceType": any;
        "bookedByInfoData": { [key: string]: any };
        "bookingData": { [key: string]: any };
        "countries": ICountry[];
        "currency": ICurrency;
        "dateRangeData": { [key: string]: any };
        "defaultGuestData": IglBookPropertyPayloadEditBooking;
        "isEditOrAddRoomEvent": boolean;
        "isLoading": string;
        "language": string;
        "propertyId": number;
        "selectedGuestData": any;
        "selectedRooms": Map<string, Map<string, any>>;
        "showPaymentDetails": boolean;
        "showSplitBookingOption": boolean;
    }
    interface IglBookingOverviewPage {
        "adultChildConstraints": TAdultChildConstraints1;
        "adultChildCount": { adult: number; child: number };
        "bookedByInfoData": any;
        "bookingData": any;
        "currency": any;
        "dateRangeData": any;
        "defaultDaterange": { from_date: string; to_date: string };
        "eventType": string;
        "initialRoomIds": any;
        "message": string;
        "propertyId": number;
        "ratePricingMode": any;
        "selectedRooms": Map<string, Map<string, any>>;
        "showSplitBookingOption": boolean;
        "sourceOptions": TSourceOptions[];
        "wasBlockedUnit": boolean;
    }
    interface IglBulkStopSale {
        "maxDatesLength": number;
    }
    interface IglCalBody {
        "calendarData": { [key: string]: any };
        "countries": ICountry[];
        "currency": any;
        "highlightedDate": string;
        "isScrollViewDragging": boolean;
        "language": string;
        "propertyId": number;
        "today": String;
    }
    interface IglCalFooter {
        "calendarData": { [key: string]: any };
        "highlightedDate": string;
        "today": String;
    }
    interface IglCalHeader {
        "calendarData": { [key: string]: any };
        "highlightedDate": string;
        "propertyid": number;
        "to_date": string;
        "today": String;
        "unassignedDates": any;
    }
    interface IglDateRange {
        "dateLabel": string;
        "defaultData": { [key: string]: any };
        "disabled": boolean;
        "maxDate": string;
        "minDate": string;
        "variant": 'booking' | 'default';
        "withDateDifference": boolean;
    }
    interface IglLegends {
        "legendData": { [key: string]: any };
    }
    interface IglPropertyBookedBy {
        "countries": ICountry[];
        "defaultData": { [key: string]: any };
        "language": string;
        "propertyId": number;
        "showPaymentDetails": boolean;
    }
    interface IglRatePlan {
        "bookingType": string;
        "currency": { symbol: string };
        "isBookDisabled": boolean;
        "ratePlan": RatePlan;
        "ratePricingMode": Array<{ CODE_NAME: string; CODE_VALUE_EN: string }>;
        "roomTypeId": number;
        "shouldBeDisabled": boolean;
        "visibleInventory": IRatePlanSelection;
    }
    interface IglRoomType {
        "bookingType": string;
        "currency": any;
        "dateDifference": number;
        "initialRoomIds": any;
        "isBookDisabled": boolean;
        "ratePricingMode": any[];
        "roomInfoId": number | null;
        "roomType": RoomType;
    }
    interface IglTbaBookingView {
        "calendarData": { [key: string]: any };
        "categoriesData": { [key: string]: any };
        "categoryId": any;
        "categoryIndex": any;
        "eventData": { [key: string]: any };
        "eventIndex": any;
        "selectedDate": any;
    }
    interface IglTbaCategoryView {
        "calendarData": { [key: string]: any };
        "categoriesData": { [key: string]: any };
        "categoryId": any;
        "categoryIndex": any;
        "eventDatas": any;
        "selectedDate": any;
    }
    interface IglToBeAssigned {
        "calendarData": { [key: string]: any };
        "from_date": string;
        "propertyid": number;
        "to_date": string;
        "unassignedDatesProp": any;
    }
    interface IglooCalendar {
        "baseUrl": string;
        "currencyName": string;
        "from_date": string;
        "language": string;
        "loadingMessage": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
        "to_date": string;
    }
    interface IrAutocomplete {
        "danger_border": boolean;
        "disabled": boolean;
        "duration": number;
        "from_date": string;
        "inputId": string;
        "isSplitBooking": boolean;
        "name": string;
        "placeholder": string;
        "propertyId": number;
        "required": boolean;
        "testId": string;
        "to_date": string;
        "type": 'email' | 'text' | 'password' | 'number' | 'search';
        "value": string;
    }
    interface IrBooking {
        "bookingNumber": string;
        "p": string;
        "propertyid": number;
    }
    interface IrBookingDetails {
        "bookingNumber": string;
        "hasCheckIn": boolean;
        "hasCheckOut": boolean;
        "hasCloseButton": boolean;
        "hasDelete": boolean;
        "hasMenu": boolean;
        "hasPrint": boolean;
        "hasReceipt": boolean;
        "hasRoomAdd": boolean;
        "hasRoomDelete": boolean;
        "hasRoomEdit": boolean;
        "is_from_front_desk": boolean;
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
    }
    interface IrBookingExtraNote {
        "booking": Booking;
    }
    interface IrBookingHeader {
        "booking": Booking;
        "hasCloseButton": boolean;
        "hasDelete": boolean;
        "hasEmail": boolean;
        "hasMenu": boolean;
        "hasPrint": boolean;
        "hasReceipt": boolean;
    }
    interface IrBookingListing {
        "baseUrl": string;
        "language": string;
        "p": string;
        "propertyid": number;
        "rowCount": number;
        "ticket": string;
    }
    interface IrBookingPrinting {
        "bookingNumber": string;
        "countries": any;
        "language": string;
        "mode": 'invoice' | 'default';
        "propertyid": number;
        "token": string;
    }
    interface IrButton {
        /**
          * Triggers a bounce animation on the button.
         */
        "bounce": () => Promise<void>;
        /**
          * Custom inline styles for the button element.
         */
        "btnStyle": { [key: string]: string };
        /**
          * Whether the button should expand to the full width of its container.
         */
        "btn_block": boolean;
        /**
          * The color theme of the button.
         */
        "btn_color": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | 'outline' | 'link';
        /**
          * Disables the button when set to true.
         */
        "btn_disabled": boolean;
        /**
          * A unique identifier for the button instance.
         */
        "btn_id": string;
        /**
          * Additional custom class names for the button.
         */
        "btn_styles": string;
        /**
          * The button type attribute (`button`, `submit`, or `reset`).
         */
        "btn_type": string;
        /**
          * Position of the icon relative to the button text.
         */
        "iconPosition": 'left' | 'right';
        /**
          * The name of the icon to display.
         */
        "icon_name": TIcons;
        /**
          * Custom style object for the icon.
         */
        "icon_style": any;
        /**
          * Displays a loading indicator when true and disables the button.
         */
        "isLoading": boolean;
        /**
          * Custom inline styles for the label/text inside the button.
         */
        "labelStyle": { [key: string]: string };
        /**
          * The name of the button, used for identification purposes.
         */
        "name": string;
        /**
          * If true, renders the text property as raw HTML inside the button.
         */
        "renderContentAsHtml": boolean;
        /**
          * The size of the button.
         */
        "size": 'sm' | 'md' | 'lg';
        /**
          * The text content displayed inside the button.
         */
        "text": string;
        /**
          * The size of the text inside the button.
         */
        "textSize": 'sm' | 'md' | 'lg';
        /**
          * Visual variant of the button: either standard (`default`) or icon-only (`icon`).
         */
        "variant": 'default' | 'icon';
        /**
          * If true, applies a visible background when hovered.
         */
        "visibleBackgroundOnHover": boolean;
    }
    interface IrChannel {
        "baseurl": string;
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
    }
    interface IrChannelEditor {
        "channel_status": 'create' | 'edit' | null;
        "ticket": string;
    }
    interface IrChannelGeneral {
        "channel_status": 'create' | 'edit' | null;
    }
    interface IrChannelHeader {
        "headerTitles": { id: string; name: string; disabled: boolean }[];
    }
    interface IrChannelMapping {
    }
    interface IrCheckbox {
        /**
          * The unique ID of the checkbox element.
         */
        "checkboxId": string;
        /**
          * Whether the checkbox is checked.
         */
        "checked": boolean;
        /**
          * Disables the checkbox when true.
         */
        "disabled": boolean;
        /**
          * Whether the checkbox is in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * The label text associated with the checkbox.
         */
        "label": string;
        /**
          * CSS class applied to the label element.
         */
        "labelClass": string;
        /**
          * The name attribute of the checkbox, used for form submission.
         */
        "name": string;
    }
    interface IrCheckboxes {
        "checkboxes": checkboxes[];
    }
    interface IrCombobox {
        /**
          * Autofocuses the input field when true.
         */
        "autoFocus": boolean;
        /**
          * The list of items displayed in the combobox.
         */
        "data": ComboboxItem[];
        /**
          * Disables the combobox input when set to true.
         */
        "disabled": boolean;
        /**
          * Debounce duration in milliseconds for search input.
         */
        "duration": number;
        /**
          * Unique identifier for the input element.
         */
        "input_id": string;
        /**
          * Placeholder text for the input field.
         */
        "placeholder": string;
        /**
          * The current value of the input field.
         */
        "value": string;
    }
    interface IrCommon {
        "extraResources": string;
    }
    interface IrCountryPicker {
        /**
          * Whether to automatically validate the input.
         */
        "autoValidate": boolean;
        /**
          * List of countries to display in the dropdown.
         */
        "countries": ICountry[];
        /**
          * Currently selected country.
         */
        "country": ICountry;
        /**
          * Whether to show an error state on the input.
         */
        "error": boolean;
        /**
          * The label to display for the input.
         */
        "label": string;
        /**
          * The property-associated country, shown separately if relevant.
         */
        "propertyCountry": ICountry;
        /**
          * Test ID for automated testing.
         */
        "testId": string;
    }
    interface IrDatePicker {
        /**
          * Closes the picker automatically after a date is selected.
         */
        "autoClose": boolean;
        "clearDatePicker": () => Promise<void>;
        /**
          * Pass a container element if you need the date picker to be appended to a specific element for styling or positioning (particularly for arrow rendering). If not provided, it defaults to `this.el`.
         */
        "container"?: HTMLElement;
        /**
          * Controls how the date picker is triggered. - **`true`**: The picker can be triggered by custom UI elements (provided via a `<slot name="trigger">`). - **`false`**: A default button input is used to open the picker.  Defaults to `true`.
         */
        "customPicker": boolean;
        /**
          * The initially selected date; can be a `Date` object or a string recognized by `AirDatepicker`.
         */
        "date": string | Date | null;
        /**
          * Format for the date as it appears in the input field. Follows the `AirDatepicker` format rules.
         */
        "dateFormat": string;
        /**
          * Disables the input and prevents interaction.
         */
        "disabled": boolean;
        /**
          * If `true`, the component will emit a `dateChanged` event when the selected date becomes empty (null). Otherwise, empty-date changes will be ignored (no event emitted).  Defaults to `false`.
         */
        "emitEmptyDate": boolean;
        /**
          * If `true`, the date picker instance is destroyed and rebuilt each time the `date` prop changes. This can be useful if you need the picker to fully re-initialize in response to dynamic changes, but note that it may affect performance if triggered frequently. Defaults to `false`.
         */
        "forceDestroyOnUpdate": boolean;
        /**
          * Determines whether the date picker is rendered inline or in a pop-up. If `true`, the picker is always visible inline.
         */
        "inline": boolean;
        /**
          * The latest date that can be selected.
         */
        "maxDate"?: string | Date;
        /**
          * The earliest date that can be selected.
         */
        "minDate"?: string | Date;
        /**
          * Enables multiple dates. If `true`, multiple selection is allowed. If you pass a number (e.g. 3), that is the maximum number of selectable dates.
         */
        "multipleDates": boolean | number;
        "openDatePicker": () => Promise<void>;
        /**
          * Whether the picker should allow range selection (start and end date).
         */
        "range": boolean;
        /**
          * Allows selecting days from previous/next month shown in the current view.
         */
        "selectOtherMonths": boolean;
        /**
          * Shows days from previous/next month in the current month's calendar.
         */
        "showOtherMonths": boolean;
        /**
          * Enables the timepicker functionality (select hours and minutes).
         */
        "timepicker": boolean;
        /**
          * Styles for the trigger container
         */
        "triggerContainerStyle": string;
    }
    interface IrDateRange {
        /**
          * Text shown on the Apply button.
         */
        "applyLabel": string;
        /**
          * Whether to apply the selected range automatically without clicking 'Apply'.
         */
        "autoApply": boolean;
        /**
          * Text shown on the Cancel button.
         */
        "cancelLabel": string;
        /**
          * Label used for the custom date range option.
         */
        "customRangeLabel": string;
        /**
          * Single date selection value (used in single date picker mode).
         */
        "date": Date;
        /**
          * Abbreviated names of the days of the week.
         */
        "daysOfWeek": string[];
        /**
          * Disables the date range input when true.
         */
        "disabled": boolean;
        /**
          * First day of the week (0 = Sunday, 1 = Monday, ...).
         */
        "firstDay": number;
        /**
          * Date format used in the input and picker.
         */
        "format": string;
        /**
          * Start date for the date range.
         */
        "fromDate": Date;
        /**
          * Label for the "From" date input.
         */
        "fromLabel": string;
        /**
          * Maximum selectable date.
         */
        "maxDate": string | Date;
        /**
          * Maximum range span (e.g., `{ days: 240 }`).
         */
        "maxSpan": moment.DurationInputArg1;
        /**
          * Minimum selectable date.
         */
        "minDate": string | Date;
        /**
          * Month names shown in the calendar header.
         */
        "monthNames": string[];
        /**
          * Opens the date picker programmatically.  Example: ```ts const el = document.querySelector('ir-date-range'); await el.openDatePicker(); ```
         */
        "openDatePicker": () => Promise<void>;
        /**
          * Defines which side the calendar opens to. Options: `'left'`, `'right'`, `'center'`.
         */
        "opens": 'left' | 'right' | 'center';
        /**
          * Separator string used between start and end dates.
         */
        "separator": string;
        /**
          * Enables single date selection mode.
         */
        "singleDatePicker": boolean;
        /**
          * End date for the date range.
         */
        "toDate": Date;
        /**
          * Label for the "To" date input.
         */
        "toLabel": string;
        /**
          * Label for the week column in the calendar.
         */
        "weekLabel": string;
    }
    interface IrDateView {
        "dateOption": string;
        "from_date": string | Date | moment.Moment;
        "showDateDifference": boolean;
        "to_date": string | Date | moment.Moment;
    }
    interface IrDeleteModal {
        "closeModal": () => Promise<void>;
        "openModal": () => Promise<void>;
        "user": IHouseKeepers;
    }
    interface IrDialog {
        /**
          * Closes the modal dialog programmatically. Reverts body scroll and emits `openChange`.
         */
        "closeModal": () => Promise<void>;
        /**
          * Controls whether the dialog should be opened. Can be updated externally and watched internally.
         */
        "open": boolean;
        /**
          * Opens the modal dialog programmatically. Applies `overflow: hidden` to the `body`.  Example: ```ts const dialog = document.querySelector('ir-dialog'); await dialog.openModal(); ```
         */
        "openModal": () => Promise<void>;
    }
    interface IrDrawer {
        "closeDrawer": () => Promise<void>;
        /**
          * The title of the drawer
         */
        "drawerTitle": string;
        /**
          * Is the drawer open?
         */
        "open": boolean;
        /**
          * The placement of the drawer
         */
        "placement": 'left' | 'right';
    }
    interface IrDropdown {
        "data": {
    name: string;
    icon: string;
    children: {
      name: string;
      icon: string;
    }[];
  };
        "object": any;
    }
    interface IrEventsLog {
        "bookingNumber": string;
    }
    interface IrExtraService {
        "bookingNumber": string;
        "currencySymbol": string;
        "service": ExtraService;
    }
    interface IrExtraServiceConfig {
        "booking": Pick<Booking, 'from_date' | 'to_date' | 'currency' | 'booking_nbr'>;
        "service": ExtraService;
    }
    interface IrExtraServices {
        "booking": Pick<Booking, 'currency' | 'extra_services' | 'booking_nbr'>;
    }
    interface IrGuestInfo {
        "booking_nbr": string;
        "email": string;
        "headerShown": boolean;
        "isInSideBar": boolean;
        "language": string;
        "ticket": string;
    }
    interface IrHkArchive {
        "language": string;
        "propertyId": string | number;
        "ticket": string;
    }
    interface IrHkTasks {
        "baseUrl": string;
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
    }
    interface IrHkTeam {
    }
    interface IrHkUnassignedUnits {
        "user": IHouseKeepers | null;
    }
    interface IrHkUser {
        "isEdit": boolean;
        "user": THKUser | null;
    }
    interface IrHousekeeping {
        "baseUrl": string;
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
    }
    interface IrIcon {
        "icon": string;
        "type": 'button' | 'submit' | 'reset';
    }
    interface IrIcons {
        /**
          * Sets the `color` attribute on the `<svg>` element. Accepts any valid CSS color string.
         */
        "color": string;
        /**
          * The name of the icon to render. Must match a key from the imported `icons` map.  Example: ```tsx <ir-icons name="check" /> ```
         */
        "name": TIcons;
        /**
          * Additional CSS class applied to the `<svg>` element. Can be used for sizing, positioning, etc.
         */
        "svgClassName": string;
    }
    interface IrInputText {
        /**
          * A Zod parse type for validating the input
         */
        "asyncParse"?: boolean;
        /**
          * Autocomplete behavior for the input (e.g., 'on', 'off', 'email', etc.)
         */
        "autoComplete": string;
        /**
          * Whether the input should auto-validate
         */
        "autoValidate"?: boolean;
        /**
          * To clear all the Input base styling
         */
        "clearBaseStyles": boolean;
        /**
          * Whether the input is disabled
         */
        "disabled": boolean;
        /**
          * Whether the input has an error
         */
        "error": boolean;
        /**
          * To clear all the Input base styling
         */
        "errorMessage": string;
        /**
          * Forcing css style to the input
         */
        "inputForcedStyle"?: { [key: string]: string };
        /**
          * Whether to apply default input styling
         */
        "inputStyle": boolean;
        /**
          * Additional inline styles for the input
         */
        "inputStyles": string;
        /**
          * Label text for the input
         */
        "label": string;
        /**
          * Background color of the label
         */
        "labelBackground": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | null;
        /**
          * Border color/style of the label
         */
        "labelBorder": 'theme' | 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | 'none';
        /**
          * Text color of the label
         */
        "labelColor": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        /**
          * Position of the label: left, right, or center
         */
        "labelPosition": 'left' | 'right' | 'center';
        /**
          * Label width as a fraction of 12 columns (1-11)
         */
        "labelWidth": 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
        /**
          * Mask for the input field (optional)
         */
        "mask": FactoryArg;
        /**
          * Input max character length
         */
        "maxLength": number;
        /**
          * Name attribute for the input field
         */
        "name": string;
        /**
          * Placeholder text for the input
         */
        "placeholder": string;
        /**
          * Whether the input field is read-only
         */
        "readonly": boolean;
        /**
          * Whether the input field is required
         */
        "required": boolean;
        /**
          * Whether the form has been submitted
         */
        "submitted": boolean;
        /**
          * Input id for testing purposes
         */
        "testId": string;
        /**
          * Text size inside the input field
         */
        "textSize": 'sm' | 'md' | 'lg';
        /**
          * Input type (e.g., text, password, email)
         */
        "type": | 'text'
    | 'password'
    | 'email'
    | 'number'
    | 'tel'
    | 'url'
    | 'search'
    | 'date'
    | 'datetime-local'
    | 'month'
    | 'week'
    | 'time'
    | 'color'
    | 'file'
    | 'hidden'
    | 'checkbox'
    | 'radio'
    | 'range'
    | 'button'
    | 'reset'
    | 'submit'
    | 'image';
        /**
          * Value of the input field
         */
        "value": string;
        /**
          * Variant of the input: default or icon
         */
        "variant": 'default' | 'icon';
        /**
          * Key to wrap the value (e.g., 'price' or 'cost')
         */
        "wrapKey"?: string;
        /**
          * A Zod schema for validating the input
         */
        "zod"?: ZodType<any, any>;
    }
    interface IrInteractiveTitle {
        /**
          * The number of characters to display before cropping the title with ellipsis.
         */
        "cropSize": number;
        /**
          * Whether to show the housekeeping (HK) status dot.
         */
        "hkStatus": boolean;
        /**
          * CSS offset for the left position of the popover. Used as a CSS variable `--ir-popover-left`.
         */
        "irPopoverLeft": string;
        /**
          * The full title string that may be cropped in the UI.
         */
        "popoverTitle": string;
    }
    interface IrInterceptor {
        /**
          * List of endpoint paths that should trigger loader logic and OTP handling.
         */
        "handledEndpoints": string[];
        /**
          * List of endpoints for which to suppress toast messages.
         */
        "suppressToastEndpoints": string[];
    }
    interface IrLabel {
        /**
          * inline styles for the component container
         */
        "containerStyle": {
    [key: string]: string;
  };
        /**
          * The main text or HTML content to display
         */
        "content": string;
        "display": 'inline' | 'flex';
        /**
          * If true, label will ignore checking for an empty content
         */
        "ignoreEmptyContent": boolean;
        /**
          * Object representing the image used within the label
         */
        "image"?: { src: string; alt: string; style?: string } | null;
        /**
          * Additional CSS classes or style for the image
         */
        "imageStyle": string;
        /**
          * Renders a country-type image style (vs. a 'logo')
         */
        "isCountryImage": boolean;
        /**
          * The text to display as the label's title
         */
        "labelText": string;
        /**
          * Placeholder text to display if content is empty
         */
        "placeholder": string;
        /**
          * If true, will render `content` as HTML
         */
        "renderContentAsHtml": boolean;
    }
    interface IrListingHeader {
        "language": string;
        "p": string;
        "propertyId": number;
    }
    interface IrListingModal {
        "closeModal": () => Promise<void>;
        "editBooking": { booking: Booking; cause: 'edit' | 'payment' | 'delete' | 'guest' };
        "modalTitle": string;
        "openModal": () => Promise<void>;
    }
    interface IrLoadingScreen {
        "message": string;
    }
    interface IrLogin {
    }
    interface IrModal {
        /**
          * If true, the modal automatically closes after confirm/cancel actions.
         */
        "autoClose": boolean;
        /**
          * Horizontal alignment of the footer buttons.
         */
        "btnPosition": 'left' | 'right' | 'center';
        /**
          * Closes the modal.
         */
        "closeModal": () => Promise<void>;
        /**
          * Icon name to render next to the title (if `iconAvailable` is true).
         */
        "icon": string;
        /**
          * Whether an icon should be displayed next to the title.
         */
        "iconAvailable": boolean;
        /**
          * Whether the modal is in a loading state, disabling interaction.
         */
        "isLoading": boolean;
        /**
          * Payload object to pass along with confirm/cancel events.
         */
        "item": any;
        /**
          * Whether the left (cancel/close) button is visible.
         */
        "leftBtnActive": boolean;
        /**
          * Color theme of the left button.
         */
        "leftBtnColor": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        /**
          * Text displayed on the left (cancel/close) button.
         */
        "leftBtnText": string;
        /**
          * The main content text shown in the modal body.
         */
        "modalBody": string;
        /**
          * The title text displayed in the modal header.
         */
        "modalTitle": string;
        /**
          * Opens the modal.  Example: ```ts const modal = document.querySelector('ir-modal'); modal.openModal(); ```
         */
        "openModal": () => Promise<void>;
        /**
          * Whether the right (confirm) button is visible.
         */
        "rightBtnActive": boolean;
        /**
          * Color theme of the right button.
         */
        "rightBtnColor": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        /**
          * Text displayed on the right (confirm) button.
         */
        "rightBtnText": string;
        /**
          * Controls whether the modal title is rendered.
         */
        "showTitle": boolean;
    }
    interface IrOptionDetails {
        "propertyId": string;
    }
    interface IrOtaService {
        "service": OtaService;
    }
    interface IrOtaServices {
        "services": OtaService[];
    }
    interface IrOtp {
        /**
          * Auto focus on the first input when component loads
         */
        "autoFocus": boolean;
        /**
          * The default OTP code
         */
        "defaultValue": string;
        /**
          * Whether the input is disabled
         */
        "disabled": boolean;
        /**
          * The length of the OTP code
         */
        "length": number;
        /**
          * Allow only numbers (0-9) as input
         */
        "numbersOnly": boolean;
        /**
          * Placeholder character to display
         */
        "placeholder": string;
        /**
          * Whether to mask the input (show dots instead of text)
         */
        "secure": boolean;
        /**
          * Input type - can be 'text', 'password', 'number', or 'tel'
         */
        "type": 'text' | 'password' | 'number' | 'tel';
    }
    interface IrOtpModal {
        /**
          * URL or endpoint used to validate the OTP
         */
        "baseOTPUrl": string;
        /**
          * Hide & clear timer
         */
        "closeModal": () => Promise<void>;
        /**
          * User's email address to display in the modal and send the OTP to
         */
        "email": string;
        "language": string;
        /**
          * Open & reset everything
         */
        "openModal": () => Promise<void>;
        /**
          * Number of digits the OTP should have
         */
        "otpLength": number;
        /**
          * URL or endpoint used to validate the OTP
         */
        "requestUrl": string;
        /**
          * Number of seconds to wait before allowing OTP resend
         */
        "resendTimer": number;
        /**
          * Whether the resend option should be visible
         */
        "showResend": boolean;
        /**
          * ticket for verifying and resending the verification code
         */
        "ticket": string;
    }
    interface IrPasswordValidator {
        /**
          * The password string to validate
         */
        "password": string;
    }
    interface IrPaymentActions {
        "booking": Booking;
        "paymentAction": IPaymentAction[];
    }
    interface IrPaymentDetails {
        "bookingDetails": Booking;
        "paymentActions": IPaymentAction[];
    }
    interface IrPaymentOption {
        "defaultStyles": boolean;
        "hideLogs": boolean;
        "language": string;
        "p": string;
        "propertyid": string;
        "ticket": string;
    }
    interface IrPhoneInput {
        /**
          * Country list, used to populate prefix and dropdown. If not provided, fetched from the booking service.
         */
        "countries": ICountry[];
        /**
          * Default country ID used if no phone prefix is set.
         */
        "default_country": number;
        /**
          * Disables the phone input when true.
         */
        "disabled": boolean;
        /**
          * If true, styles the input to indicate an error state.
         */
        "error": boolean;
        /**
          * Label displayed next to the phone input.
         */
        "label": string;
        /**
          * Two-letter language code used for country fetching.
         */
        "language": string;
        /**
          * If provided, sets the phone prefix and updates selected country.
         */
        "phone_prefix": string | null;
        /**
          * Placeholder text for the input.
         */
        "placeholder": string;
        /**
          * Identifier for test automation.
         */
        "testId": string;
        /**
          * Auth token used by the booking service (if needed).
         */
        "token": string;
        /**
          * Initial phone number value.
         */
        "value": string;
    }
    interface IrPickup {
        "bookingDates": { from: string; to: string };
        "bookingNumber": string;
        "defaultPickupData": IBookingPickupInfo | null;
        "numberOfPersons": number;
    }
    interface IrPickupView {
        "booking": Booking;
    }
    interface IrPmsLogs {
        "bookingNumber": string;
    }
    interface IrPopover {
        /**
          * Content to display inside the popover. Can be plain text or HTML depending on `renderContentAsHtml`.
         */
        "content": string;
        /**
          * Horizontal offset (left) of the popover from its trigger. Used in inline style as `--ir-popover-left`.
         */
        "irPopoverLeft": string;
        /**
          * Position of the popover relative to the trigger. Options: `'top'`, `'bottom'`, `'left'`, `'right'`, `'auto'`.
         */
        "placement": 'top' | 'bottom' | 'left' | 'right' | 'auto';
        /**
          * Whether to treat `content` as raw HTML. When true, `content` will be injected with `html: true` in jQuery popover.
         */
        "renderContentAsHtml": boolean;
        /**
          * Event that triggers the popover. Options: `'focus'`, `'click'`, `'hover'`.
         */
        "trigger": 'focus' | 'click' | 'hover';
    }
    interface IrPriceInput {
        /**
          * The AutoValidate for the input, optional
         */
        "autoValidate"?: boolean;
        /**
          * The Currency for the input, optional
         */
        "currency"?: string;
        /**
          * The disabled for the input, optional
         */
        "disabled"?: boolean;
        /**
          * Extra classnames for the input, optional
         */
        "inputStyle"?: string;
        /**
          * The label for the input, optional
         */
        "label"?: string;
        /**
          * Extra classnames for the label, optional
         */
        "labelStyle"?: string;
        /**
          * Maximum value for the price
         */
        "maxValue"?: number;
        /**
          * Minimum value for the price
         */
        "minValue"?: number;
        /**
          * Placeholder text for the input
         */
        "placeholder": string;
        /**
          * The readonly for the input, optional
         */
        "readOnly"?: boolean;
        /**
          * Whether the input is required
         */
        "required": boolean;
        /**
          * Unique id for testing
         */
        "testId"?: string;
        /**
          * Initial value for the input
         */
        "value": string;
        /**
          * Indicates the key to wrap the value (e.g., 'price' or 'cost')
         */
        "wrapKey"?: string;
        /**
          * A Zod schema for validating the input Example: z.coerce.number()
         */
        "zod"?: ZodType<any, any>;
    }
    interface IrRadio {
        /**
          * Whether the checkbox is checked.
         */
        "checked": boolean;
        /**
          * Disables the checkbox when true.
         */
        "disabled": boolean;
        /**
          * Whether the checkbox is in an indeterminate state.
         */
        "indeterminate": boolean;
        /**
          * The label text associated with the checkbox.
         */
        "label": string;
        /**
          * CSS class applied to the label element.
         */
        "labelClass": string;
        /**
          * The name attribute of the checkbox, used for form submission.
         */
        "name": string;
        /**
          * The unique ID of the checkbox element.
         */
        "radioBoxId": string;
    }
    interface IrRangePicker {
        /**
          * Whether to all the emitted dates to be null.
         */
        "allowNullDates": boolean;
        /**
          * The start date of the range.
         */
        "fromDate": Moment;
        /**
          * The latest date that can be selected.
         */
        "maxDate"?: string | Date;
        /**
          * The earliest date that can be selected.
         */
        "minDate"?: string | Date;
        /**
          * The end date of the range.
         */
        "toDate": Moment;
        /**
          * Whether to show the overlay before the date is selected.
         */
        "withOverlay": boolean;
    }
    interface IrReservationInformation {
        "booking": Booking;
        "countries": ICountry[];
    }
    interface IrResetPassword {
        "language": string;
        "old_pwd": string;
        "skip2Fa": boolean;
        "ticket": string;
        "username": string;
    }
    interface IrRoom {
        "bedPreferences": IEntries[];
        "booking": Booking;
        "bookingIndex": number;
        "currency": string;
        "hasCheckIn": boolean;
        "hasCheckOut": boolean;
        "hasRoomAdd": boolean;
        "hasRoomDelete": boolean;
        "hasRoomEdit": boolean;
        "isEditable": boolean;
        "language": string;
        "legendData": any;
        "mealCodeName": string;
        "myRoomTypeFoodCat": string;
        "room": Room;
        "roomsInfo": any;
    }
    interface IrRoomGuests {
        /**
          * A unique booking number associated with the room. This is used for backend operations like saving guest information or checking in the room.
         */
        "bookingNumber": string;
        /**
          * A boolean indicating whether the room is in the process of being checked in. If true, additional actions like saving the room state as "checked in" are performed.
         */
        "checkIn": boolean;
        /**
          * A list of available countries. Used to populate dropdowns for selecting the {locales.entries.Lcz_Nationality} of guests.
         */
        "countries": ICountry[];
        /**
          * A unique identifier for the room. This is used to distinguish between rooms, especially when performing operations like saving or checking in guests.
         */
        "identifier": string;
        /**
          * The language used for displaying text content in the component. Defaults to English ('en'), but can be set to other supported languages.
         */
        "language": string;
        /**
          * The name of the room currently being displayed. Used to label the room in the user interface for clarity.
         */
        "roomName": string;
        /**
          * An array of people sharing the room. Contains information about the {locales.entries.Lcz_MainGuest} and additional guests, such as their name, date of birth, {locales.entries.Lcz_Nationality}, and ID details.
         */
        "sharedPersons": SharedPerson[];
        /**
          * The total number of guests for the room. Determines how many guest input forms to display in the UI.
         */
        "totalGuests": number;
    }
    interface IrRoomNights {
        "bookingNumber": string;
        "defaultDates": { from_date: string; to_date: string };
        "fromDate": string;
        "identifier": string;
        "language": string;
        "pool": string;
        "propertyId": number;
        "ticket": string;
        "toDate": string;
    }
    interface IrSalesByCountry {
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
    }
    interface IrSalesFilters {
        "isLoading": boolean;
    }
    interface IrSalesTable {
        "records": SalesRecord[];
    }
    interface IrSecureTasks {
        "bookingNumber": string;
        "p": string;
        "propertyid": number;
    }
    interface IrSelect {
        "LabelAvailable": boolean;
        "data": selectOption[];
        "disabled": boolean;
        "error": boolean;
        "firstOption": string;
        "label": string;
        "labelBackground": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | null;
        "labelBorder": 'theme' | 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | 'none';
        "labelColor": 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        "labelPosition": 'left' | 'right' | 'center';
        "labelWidth": 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
        "name": string;
        "required": boolean;
        "selectContainerStyle": string;
        "selectForcedStyles": { [key: string]: string };
        "selectStyle": boolean;
        "selectStyles": string;
        "select_id": string;
        "selectedValue": any;
        "showFirstOption": boolean;
        "size": 'sm' | 'md' | 'lg';
        "submited": boolean;
        "testId": string;
        "textSize": 'sm' | 'md' | 'lg';
    }
    interface IrSidebar {
        /**
          * Label text displayed in the sidebar header.
         */
        "label": string;
        /**
          * Identifier for the sidebar instance.
         */
        "name": string;
        /**
          * Whether the sidebar is open. Can be used with two-way binding.
         */
        "open": boolean;
        /**
          * Prevents the sidebar from closing when `toggleSidebar()` is called. When true, emits `beforeSidebarClose` instead of toggling.
         */
        "preventClose": boolean;
        /**
          * Whether to show the close (X) button in the sidebar header.
         */
        "showCloseButton": boolean;
        /**
          * Which side of the screen the sidebar appears on. Options: `'left'` or `'right'`.
         */
        "side": 'right' | 'left';
        /**
          * Inline styles applied to the sidebar container.
         */
        "sidebarStyles": Partial<CSSStyleDeclaration>;
        /**
          * Toggles the sidebar's visibility.  - If `preventClose` is true, emits `beforeSidebarClose` and does nothing else. - Otherwise, emits `irSidebarToggle` with the current `open` state.  Example: ```ts const el = document.querySelector('ir-sidebar'); await el.toggleSidebar(); ```
         */
        "toggleSidebar": () => Promise<void>;
    }
    interface IrSpan {
        "text": any;
    }
    interface IrSpinner {
        /**
          * Thickness of the spinner's border. Example: `borderWidth={4}` renders a `4px` or `4rem` thick border.
         */
        "borderWidth": number;
        /**
          * Color of the spinner. Accepts any valid CSS color string.
         */
        "color": string;
        /**
          * Size of the spinner (diameter). Example: `size={2}` with `unit="rem"` sets spinner to `2rem`.
         */
        "size": number;
        /**
          * CSS unit used for `size` and `borderWidth`. Can be `'px'` or `'rem'`.
         */
        "unit": 'px' | 'rem';
    }
    interface IrSwitch {
        /**
          * Whether the switch is currently checked (on). This is mutable and can be toggled internally.
         */
        "checked": boolean;
        /**
          * Disables the switch if true.
         */
        "disabled": boolean;
        /**
          * Optional ID for the switch. If not provided, a random ID will be generated.
         */
        "switchId": string;
    }
    interface IrTasksFilters {
        "isLoading": boolean;
    }
    interface IrTasksHeader {
        "isCleanedEnabled": boolean;
    }
    interface IrTasksTable {
        "tasks": Task[];
    }
    interface IrTestCmp {
    }
    interface IrTextEditor {
        "error": boolean;
        "maxLength": number;
        /**
          * Placeholder text
         */
        "placeholder": string;
        /**
          * If true, makes the editor read-only
         */
        "readOnly": boolean;
        /**
          * Type-safe toolbar configuration. For example, you can pass:  {   bold: true,   italic: true,   underline: true,   strike: false,   link: true,   clean: true }
         */
        "toolbarConfig"?: ToolbarConfig;
        /**
          * Determines if the current user can edit the content
         */
        "userCanEdit": boolean;
        /**
          * Initial HTML content
         */
        "value": string;
    }
    interface IrTextarea {
        /**
          * Number of visible character columns.
         */
        "cols": number;
        /**
          * Text label displayed above or beside the textarea.
         */
        "label": string;
        /**
          * Width of the label in grid columns (for `variant="prepend"`).
         */
        "labelWidth": 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
        /**
          * Maximum number of characters allowed.
         */
        "maxLength": number;
        /**
          * Placeholder text shown when input is empty.
         */
        "placeholder": string;
        /**
          * Number of visible text lines.
         */
        "rows": number;
        /**
          * Inline styles applied directly to the textarea.
         */
        "styles": { [key: string]: string };
        /**
          * `data-testid` for targeting in tests.
         */
        "testId": string;
        /**
          * Unused property, intended to store textarea text.
         */
        "text": string;
        /**
          * Additional classes for the textarea element.
         */
        "textareaClassname": string;
        /**
          * Current value of the textarea (supports two-way binding).
         */
        "value": string;
        /**
          * Layout style of the textarea: `'default'` shows label above, `'prepend'` shows label on the left.
         */
        "variant": 'default' | 'prepend';
    }
    interface IrTitle {
        "borderShown": boolean;
        "displayContext": 'default' | 'sidebar';
        "justifyContent": | 'center'
    | 'start'
    | 'end'
    | 'flex-start'
    | 'flex-end'
    | 'left'
    | 'right'
    | 'normal'
    | 'space-between'
    | 'space-around'
    | 'space-evenly'
    | 'stretch'
    | 'safe center'
    | 'unsafe center';
        "label": string;
    }
    interface IrToast {
        /**
          * Position where toasts will appear. Options include: `'top-left'`, `'top-right'`, `'bottom-left'`, `'bottom-right'`.
         */
        "position": TPositions;
    }
    interface IrTooltip {
        /**
          * Inline styles applied to the outer tooltip container.
         */
        "containerStyle": { [key: string]: string };
        /**
          * When true, allows a custom element to trigger the tooltip using a named slot. If false, a default info icon is used.
         */
        "customSlot": boolean;
        /**
          * Text or HTML content to be displayed in the tooltip.
         */
        "message": string;
        /**
          * Whether the tooltip content should be rendered using `innerHTML`. If false, treats message as plain text.
         */
        "withHtml": boolean;
    }
    interface IrUnitStatus {
    }
    interface IrUserFormPanel {
        "allowedUsersTypes": AllowedUser[];
        "baseUserTypeCode": string | number;
        "haveAdminPrivileges": boolean;
        "isEdit": boolean;
        "language": string;
        "property_id": number;
        "superAdminId": string;
        "user": User;
        "userTypeCode": string | number;
        "userTypes": { new (entries?: readonly (readonly [string | number, string])[]): Map<string | number, string>; new (iterable?: Iterable<readonly [string | number, string]>): Map<string | number, string>; readonly prototype: Map<any, any>; readonly [Symbol.species]: MapConstructor; };
    }
    interface IrUserManagement {
        "baseUrl": string;
        "baseUserTypeCode": string | number;
        "isSuperAdmin": boolean;
        "language": string;
        "p": string;
        "propertyid": number;
        "ticket": string;
        "userId": string | number;
        "userTypeCode": string | number;
    }
    interface IrUserManagementTable {
        "allowedUsersTypes": AllowedUser[];
        "baseUserTypeCode": string | number;
        "haveAdminPrivileges": boolean;
        "isSuperAdmin": boolean;
        "property_id": number;
        "superAdminId": string;
        "userTypeCode": string | number;
        "userTypes": Map<string | number, string>;
        "users": User[];
    }
    interface IrWeekdaySelector {
        /**
          * Initial list of selected weekdays (numeric values).
         */
        "weekdays": number[];
    }
    interface OtaLabel {
        /**
          * Label displayed as the section title.
         */
        "label": string;
        /**
          * Maximum number of remarks to display before showing the "Show More" button.
         */
        "maxVisibleItems": number;
        /**
          * Array of OTA notes to display in the list.
         */
        "remarks": IOtaNotes[];
    }
    interface RequirementCheck {
        /**
          * Whether this requirement has been satisfied (true/false).
         */
        "isValid": boolean;
        /**
          * The requirement text to display (e.g. "At least one lowercase letter").
         */
        "text": string;
    }
}
export interface IglBlockDatesViewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBlockDatesViewElement;
}
export interface IglBookPropertyCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookPropertyElement;
}
export interface IglBookPropertyContainerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookPropertyContainerElement;
}
export interface IglBookPropertyFooterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookPropertyFooterElement;
}
export interface IglBookPropertyHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookPropertyHeaderElement;
}
export interface IglBookingEventCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookingEventElement;
}
export interface IglBookingEventHoverCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookingEventHoverElement;
}
export interface IglBookingFormCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookingFormElement;
}
export interface IglBookingOverviewPageCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBookingOverviewPageElement;
}
export interface IglBulkStopSaleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglBulkStopSaleElement;
}
export interface IglCalBodyCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglCalBodyElement;
}
export interface IglCalFooterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglCalFooterElement;
}
export interface IglCalHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglCalHeaderElement;
}
export interface IglDateRangeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglDateRangeElement;
}
export interface IglLegendsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglLegendsElement;
}
export interface IglPropertyBookedByCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglPropertyBookedByElement;
}
export interface IglRatePlanCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglRatePlanElement;
}
export interface IglRoomTypeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglRoomTypeElement;
}
export interface IglTbaBookingViewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglTbaBookingViewElement;
}
export interface IglTbaCategoryViewCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglTbaCategoryViewElement;
}
export interface IglToBeAssignedCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglToBeAssignedElement;
}
export interface IglooCalendarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIglooCalendarElement;
}
export interface IrAutocompleteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrAutocompleteElement;
}
export interface IrBookingDetailsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrBookingDetailsElement;
}
export interface IrBookingExtraNoteCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrBookingExtraNoteElement;
}
export interface IrBookingHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrBookingHeaderElement;
}
export interface IrButtonCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrButtonElement;
}
export interface IrChannelEditorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrChannelEditorElement;
}
export interface IrChannelGeneralCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrChannelGeneralElement;
}
export interface IrChannelHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrChannelHeaderElement;
}
export interface IrCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrCheckboxElement;
}
export interface IrCheckboxesCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrCheckboxesElement;
}
export interface IrComboboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrComboboxElement;
}
export interface IrCountryPickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrCountryPickerElement;
}
export interface IrDatePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrDatePickerElement;
}
export interface IrDateRangeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrDateRangeElement;
}
export interface IrDeleteModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrDeleteModalElement;
}
export interface IrDialogCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrDialogElement;
}
export interface IrDrawerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrDrawerElement;
}
export interface IrDropdownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrDropdownElement;
}
export interface IrExtraServiceCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrExtraServiceElement;
}
export interface IrExtraServiceConfigCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrExtraServiceConfigElement;
}
export interface IrGuestInfoCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrGuestInfoElement;
}
export interface IrHkTasksCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrHkTasksElement;
}
export interface IrHkUnassignedUnitsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrHkUnassignedUnitsElement;
}
export interface IrHkUserCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrHkUserElement;
}
export interface IrHousekeepingCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrHousekeepingElement;
}
export interface IrIconCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrIconElement;
}
export interface IrInputTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrInputTextElement;
}
export interface IrInterceptorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrInterceptorElement;
}
export interface IrListingHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrListingHeaderElement;
}
export interface IrListingModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrListingModalElement;
}
export interface IrLoginCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrLoginElement;
}
export interface IrModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrModalElement;
}
export interface IrOptionDetailsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrOptionDetailsElement;
}
export interface IrOtpCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrOtpElement;
}
export interface IrOtpModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrOtpModalElement;
}
export interface IrPasswordValidatorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPasswordValidatorElement;
}
export interface IrPaymentActionsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPaymentActionsElement;
}
export interface IrPaymentDetailsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPaymentDetailsElement;
}
export interface IrPaymentOptionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPaymentOptionElement;
}
export interface IrPhoneInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPhoneInputElement;
}
export interface IrPickupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPickupElement;
}
export interface IrPriceInputCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrPriceInputElement;
}
export interface IrRadioCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrRadioElement;
}
export interface IrRangePickerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrRangePickerElement;
}
export interface IrReservationInformationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrReservationInformationElement;
}
export interface IrResetPasswordCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrResetPasswordElement;
}
export interface IrRoomCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrRoomElement;
}
export interface IrRoomGuestsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrRoomGuestsElement;
}
export interface IrRoomNightsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrRoomNightsElement;
}
export interface IrSalesFiltersCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrSalesFiltersElement;
}
export interface IrSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrSelectElement;
}
export interface IrSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrSidebarElement;
}
export interface IrSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrSwitchElement;
}
export interface IrTasksFiltersCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrTasksFiltersElement;
}
export interface IrTasksHeaderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrTasksHeaderElement;
}
export interface IrTasksTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrTasksTableElement;
}
export interface IrTextEditorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrTextEditorElement;
}
export interface IrTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrTextareaElement;
}
export interface IrTitleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrTitleElement;
}
export interface IrUnitStatusCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrUnitStatusElement;
}
export interface IrUserFormPanelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrUserFormPanelElement;
}
export interface IrUserManagementTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrUserManagementTableElement;
}
export interface IrWeekdaySelectorCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLIrWeekdaySelectorElement;
}
declare global {
    interface HTMLIglApplicationInfoElement extends Components.IglApplicationInfo, HTMLStencilElement {
    }
    var HTMLIglApplicationInfoElement: {
        prototype: HTMLIglApplicationInfoElement;
        new (): HTMLIglApplicationInfoElement;
    };
    interface HTMLIglBlockDatesViewElementEventMap {
        "dataUpdateEvent": { [key: string]: any };
    }
    interface HTMLIglBlockDatesViewElement extends Components.IglBlockDatesView, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBlockDatesViewElementEventMap>(type: K, listener: (this: HTMLIglBlockDatesViewElement, ev: IglBlockDatesViewCustomEvent<HTMLIglBlockDatesViewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBlockDatesViewElementEventMap>(type: K, listener: (this: HTMLIglBlockDatesViewElement, ev: IglBlockDatesViewCustomEvent<HTMLIglBlockDatesViewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBlockDatesViewElement: {
        prototype: HTMLIglBlockDatesViewElement;
        new (): HTMLIglBlockDatesViewElement;
    };
    interface HTMLIglBookPropertyElementEventMap {
        "closeBookingWindow": { [key: string]: any };
        "blockedCreated": RoomBlockDetails;
        "resetBookingEvt": null;
        "animateIrButton": string;
        "animateIrSelect": string;
        "toast": IToast;
    }
    interface HTMLIglBookPropertyElement extends Components.IglBookProperty, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookPropertyElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyElement, ev: IglBookPropertyCustomEvent<HTMLIglBookPropertyElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookPropertyElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyElement, ev: IglBookPropertyCustomEvent<HTMLIglBookPropertyElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookPropertyElement: {
        prototype: HTMLIglBookPropertyElement;
        new (): HTMLIglBookPropertyElement;
    };
    interface HTMLIglBookPropertyContainerElementEventMap {
        "resetBookingData": null;
    }
    interface HTMLIglBookPropertyContainerElement extends Components.IglBookPropertyContainer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookPropertyContainerElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyContainerElement, ev: IglBookPropertyContainerCustomEvent<HTMLIglBookPropertyContainerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookPropertyContainerElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyContainerElement, ev: IglBookPropertyContainerCustomEvent<HTMLIglBookPropertyContainerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookPropertyContainerElement: {
        prototype: HTMLIglBookPropertyContainerElement;
        new (): HTMLIglBookPropertyContainerElement;
    };
    interface HTMLIglBookPropertyFooterElementEventMap {
        "buttonClicked": { key: TPropertyButtonsTypes };
    }
    interface HTMLIglBookPropertyFooterElement extends Components.IglBookPropertyFooter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookPropertyFooterElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyFooterElement, ev: IglBookPropertyFooterCustomEvent<HTMLIglBookPropertyFooterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookPropertyFooterElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyFooterElement, ev: IglBookPropertyFooterCustomEvent<HTMLIglBookPropertyFooterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookPropertyFooterElement: {
        prototype: HTMLIglBookPropertyFooterElement;
        new (): HTMLIglBookPropertyFooterElement;
    };
    interface HTMLIglBookPropertyHeaderElementEventMap {
        "splitBookingDropDownChange": any;
        "sourceDropDownChange": string;
        "adultChild": any;
        "checkClicked": any;
        "buttonClicked": { key: TPropertyButtonsTypes };
        "toast": IToast;
        "spiltBookingSelected": { key: string; data: unknown };
        "animateIrButton": string;
        "animateIrSelect": string;
    }
    interface HTMLIglBookPropertyHeaderElement extends Components.IglBookPropertyHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookPropertyHeaderElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyHeaderElement, ev: IglBookPropertyHeaderCustomEvent<HTMLIglBookPropertyHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookPropertyHeaderElementEventMap>(type: K, listener: (this: HTMLIglBookPropertyHeaderElement, ev: IglBookPropertyHeaderCustomEvent<HTMLIglBookPropertyHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookPropertyHeaderElement: {
        prototype: HTMLIglBookPropertyHeaderElement;
        new (): HTMLIglBookPropertyHeaderElement;
    };
    interface HTMLIglBookingEventElementEventMap {
        "hideBubbleInfo": any;
        "updateEventData": any;
        "dragOverEventData": any;
        "showRoomNightsDialog": IRoomNightsData;
        "showDialog": CalendarModalEvent;
        "resetStreachedBooking": string;
        "toast": IToast;
        "updateBookingEvent": { [key: string]: any };
    }
    interface HTMLIglBookingEventElement extends Components.IglBookingEvent, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookingEventElementEventMap>(type: K, listener: (this: HTMLIglBookingEventElement, ev: IglBookingEventCustomEvent<HTMLIglBookingEventElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookingEventElementEventMap>(type: K, listener: (this: HTMLIglBookingEventElement, ev: IglBookingEventCustomEvent<HTMLIglBookingEventElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookingEventElement: {
        prototype: HTMLIglBookingEventElement;
        new (): HTMLIglBookingEventElement;
    };
    interface HTMLIglBookingEventHoverElementEventMap {
        "showBookingPopup": any;
        "hideBubbleInfo": any;
        "deleteButton": string;
        "bookingCreated": { pool?: string; data: any[] };
        "showDialog": CalendarModalEvent;
    }
    interface HTMLIglBookingEventHoverElement extends Components.IglBookingEventHover, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookingEventHoverElementEventMap>(type: K, listener: (this: HTMLIglBookingEventHoverElement, ev: IglBookingEventHoverCustomEvent<HTMLIglBookingEventHoverElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookingEventHoverElementEventMap>(type: K, listener: (this: HTMLIglBookingEventHoverElement, ev: IglBookingEventHoverCustomEvent<HTMLIglBookingEventHoverElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookingEventHoverElement: {
        prototype: HTMLIglBookingEventHoverElement;
        new (): HTMLIglBookingEventHoverElement;
    };
    interface HTMLIglBookingFormElementEventMap {
        "dataUpdateEvent": IPageTwoDataUpdateProps;
        "buttonClicked": {
    key: TPropertyButtonsTypes;
    data?: CustomEvent;
  };
    }
    interface HTMLIglBookingFormElement extends Components.IglBookingForm, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookingFormElementEventMap>(type: K, listener: (this: HTMLIglBookingFormElement, ev: IglBookingFormCustomEvent<HTMLIglBookingFormElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookingFormElementEventMap>(type: K, listener: (this: HTMLIglBookingFormElement, ev: IglBookingFormCustomEvent<HTMLIglBookingFormElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookingFormElement: {
        prototype: HTMLIglBookingFormElement;
        new (): HTMLIglBookingFormElement;
    };
    interface HTMLIglBookingOverviewPageElementEventMap {
        "roomsDataUpdate": any;
    }
    interface HTMLIglBookingOverviewPageElement extends Components.IglBookingOverviewPage, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBookingOverviewPageElementEventMap>(type: K, listener: (this: HTMLIglBookingOverviewPageElement, ev: IglBookingOverviewPageCustomEvent<HTMLIglBookingOverviewPageElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBookingOverviewPageElementEventMap>(type: K, listener: (this: HTMLIglBookingOverviewPageElement, ev: IglBookingOverviewPageCustomEvent<HTMLIglBookingOverviewPageElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBookingOverviewPageElement: {
        prototype: HTMLIglBookingOverviewPageElement;
        new (): HTMLIglBookingOverviewPageElement;
    };
    interface HTMLIglBulkStopSaleElementEventMap {
        "closeModal": null;
        "toast": IToast;
    }
    interface HTMLIglBulkStopSaleElement extends Components.IglBulkStopSale, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglBulkStopSaleElementEventMap>(type: K, listener: (this: HTMLIglBulkStopSaleElement, ev: IglBulkStopSaleCustomEvent<HTMLIglBulkStopSaleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglBulkStopSaleElementEventMap>(type: K, listener: (this: HTMLIglBulkStopSaleElement, ev: IglBulkStopSaleCustomEvent<HTMLIglBulkStopSaleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglBulkStopSaleElement: {
        prototype: HTMLIglBulkStopSaleElement;
        new (): HTMLIglBulkStopSaleElement;
    };
    interface HTMLIglCalBodyElementEventMap {
        "addBookingDatasEvent": any[];
        "showBookingPopup": any;
        "scrollPageToRoom": any;
    }
    interface HTMLIglCalBodyElement extends Components.IglCalBody, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglCalBodyElementEventMap>(type: K, listener: (this: HTMLIglCalBodyElement, ev: IglCalBodyCustomEvent<HTMLIglCalBodyElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglCalBodyElementEventMap>(type: K, listener: (this: HTMLIglCalBodyElement, ev: IglCalBodyCustomEvent<HTMLIglCalBodyElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglCalBodyElement: {
        prototype: HTMLIglCalBodyElement;
        new (): HTMLIglCalBodyElement;
    };
    interface HTMLIglCalFooterElementEventMap {
        "optionEvent": { [key: string]: any };
    }
    interface HTMLIglCalFooterElement extends Components.IglCalFooter, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglCalFooterElementEventMap>(type: K, listener: (this: HTMLIglCalFooterElement, ev: IglCalFooterCustomEvent<HTMLIglCalFooterElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglCalFooterElementEventMap>(type: K, listener: (this: HTMLIglCalFooterElement, ev: IglCalFooterCustomEvent<HTMLIglCalFooterElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglCalFooterElement: {
        prototype: HTMLIglCalFooterElement;
        new (): HTMLIglCalFooterElement;
    };
    interface HTMLIglCalHeaderElementEventMap {
        "optionEvent": { [key: string]: any };
        "gotoRoomEvent": {
    [key: string]: any;
  };
        "gotoToBeAssignedDate": {
    [key: string]: any;
  };
    }
    interface HTMLIglCalHeaderElement extends Components.IglCalHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglCalHeaderElementEventMap>(type: K, listener: (this: HTMLIglCalHeaderElement, ev: IglCalHeaderCustomEvent<HTMLIglCalHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglCalHeaderElementEventMap>(type: K, listener: (this: HTMLIglCalHeaderElement, ev: IglCalHeaderCustomEvent<HTMLIglCalHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglCalHeaderElement: {
        prototype: HTMLIglCalHeaderElement;
        new (): HTMLIglCalHeaderElement;
    };
    interface HTMLIglDateRangeElementEventMap {
        "dateSelectEvent": { [key: string]: any };
        "toast": IToast;
    }
    interface HTMLIglDateRangeElement extends Components.IglDateRange, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglDateRangeElementEventMap>(type: K, listener: (this: HTMLIglDateRangeElement, ev: IglDateRangeCustomEvent<HTMLIglDateRangeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglDateRangeElementEventMap>(type: K, listener: (this: HTMLIglDateRangeElement, ev: IglDateRangeCustomEvent<HTMLIglDateRangeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglDateRangeElement: {
        prototype: HTMLIglDateRangeElement;
        new (): HTMLIglDateRangeElement;
    };
    interface HTMLIglLegendsElementEventMap {
        "optionEvent": { [key: string]: any };
    }
    interface HTMLIglLegendsElement extends Components.IglLegends, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglLegendsElementEventMap>(type: K, listener: (this: HTMLIglLegendsElement, ev: IglLegendsCustomEvent<HTMLIglLegendsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglLegendsElementEventMap>(type: K, listener: (this: HTMLIglLegendsElement, ev: IglLegendsCustomEvent<HTMLIglLegendsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglLegendsElement: {
        prototype: HTMLIglLegendsElement;
        new (): HTMLIglLegendsElement;
    };
    interface HTMLIglPropertyBookedByElementEventMap {
        "dataUpdateEvent": { [key: string]: any };
    }
    interface HTMLIglPropertyBookedByElement extends Components.IglPropertyBookedBy, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglPropertyBookedByElementEventMap>(type: K, listener: (this: HTMLIglPropertyBookedByElement, ev: IglPropertyBookedByCustomEvent<HTMLIglPropertyBookedByElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglPropertyBookedByElementEventMap>(type: K, listener: (this: HTMLIglPropertyBookedByElement, ev: IglPropertyBookedByCustomEvent<HTMLIglPropertyBookedByElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglPropertyBookedByElement: {
        prototype: HTMLIglPropertyBookedByElement;
        new (): HTMLIglPropertyBookedByElement;
    };
    interface HTMLIglRatePlanElementEventMap {
        "buttonClicked": { [key: string]: any };
    }
    interface HTMLIglRatePlanElement extends Components.IglRatePlan, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglRatePlanElementEventMap>(type: K, listener: (this: HTMLIglRatePlanElement, ev: IglRatePlanCustomEvent<HTMLIglRatePlanElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglRatePlanElementEventMap>(type: K, listener: (this: HTMLIglRatePlanElement, ev: IglRatePlanCustomEvent<HTMLIglRatePlanElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglRatePlanElement: {
        prototype: HTMLIglRatePlanElement;
        new (): HTMLIglRatePlanElement;
    };
    interface HTMLIglRoomTypeElementEventMap {
        "dataUpdateEvent": { [key: string]: any };
    }
    interface HTMLIglRoomTypeElement extends Components.IglRoomType, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglRoomTypeElementEventMap>(type: K, listener: (this: HTMLIglRoomTypeElement, ev: IglRoomTypeCustomEvent<HTMLIglRoomTypeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglRoomTypeElementEventMap>(type: K, listener: (this: HTMLIglRoomTypeElement, ev: IglRoomTypeCustomEvent<HTMLIglRoomTypeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglRoomTypeElement: {
        prototype: HTMLIglRoomTypeElement;
        new (): HTMLIglRoomTypeElement;
    };
    interface HTMLIglTbaBookingViewElementEventMap {
        "highlightToBeAssignedBookingEvent": any;
        "openCalendarSidebar": CalendarSidebarState;
        "addToBeAssignedEvent": any;
        "scrollPageToRoom": any;
        "assignRoomEvent": { [key: string]: any };
    }
    interface HTMLIglTbaBookingViewElement extends Components.IglTbaBookingView, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglTbaBookingViewElementEventMap>(type: K, listener: (this: HTMLIglTbaBookingViewElement, ev: IglTbaBookingViewCustomEvent<HTMLIglTbaBookingViewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglTbaBookingViewElementEventMap>(type: K, listener: (this: HTMLIglTbaBookingViewElement, ev: IglTbaBookingViewCustomEvent<HTMLIglTbaBookingViewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglTbaBookingViewElement: {
        prototype: HTMLIglTbaBookingViewElement;
        new (): HTMLIglTbaBookingViewElement;
    };
    interface HTMLIglTbaCategoryViewElementEventMap {
        "assignUnitEvent": { [key: string]: any };
    }
    interface HTMLIglTbaCategoryViewElement extends Components.IglTbaCategoryView, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglTbaCategoryViewElementEventMap>(type: K, listener: (this: HTMLIglTbaCategoryViewElement, ev: IglTbaCategoryViewCustomEvent<HTMLIglTbaCategoryViewElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglTbaCategoryViewElementEventMap>(type: K, listener: (this: HTMLIglTbaCategoryViewElement, ev: IglTbaCategoryViewCustomEvent<HTMLIglTbaCategoryViewElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglTbaCategoryViewElement: {
        prototype: HTMLIglTbaCategoryViewElement;
        new (): HTMLIglTbaCategoryViewElement;
    };
    interface HTMLIglToBeAssignedElementEventMap {
        "optionEvent": { [key: string]: any };
        "reduceAvailableUnitEvent": { [key: string]: any };
        "showBookingPopup": any;
        "addToBeAssignedEvent": any;
        "highlightToBeAssignedBookingEvent": any;
    }
    interface HTMLIglToBeAssignedElement extends Components.IglToBeAssigned, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglToBeAssignedElementEventMap>(type: K, listener: (this: HTMLIglToBeAssignedElement, ev: IglToBeAssignedCustomEvent<HTMLIglToBeAssignedElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglToBeAssignedElementEventMap>(type: K, listener: (this: HTMLIglToBeAssignedElement, ev: IglToBeAssignedCustomEvent<HTMLIglToBeAssignedElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglToBeAssignedElement: {
        prototype: HTMLIglToBeAssignedElement;
        new (): HTMLIglToBeAssignedElement;
    };
    interface HTMLIglooCalendarElementEventMap {
        "dragOverHighlightElement": any;
        "moveBookingTo": any;
        "calculateUnassignedDates": any;
        "reduceAvailableUnitEvent": { fromDate: string; toDate: string };
        "revertBooking": any;
        "openCalendarSidebar": CalendarSidebarState;
    }
    interface HTMLIglooCalendarElement extends Components.IglooCalendar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIglooCalendarElementEventMap>(type: K, listener: (this: HTMLIglooCalendarElement, ev: IglooCalendarCustomEvent<HTMLIglooCalendarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIglooCalendarElementEventMap>(type: K, listener: (this: HTMLIglooCalendarElement, ev: IglooCalendarCustomEvent<HTMLIglooCalendarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIglooCalendarElement: {
        prototype: HTMLIglooCalendarElement;
        new (): HTMLIglooCalendarElement;
    };
    interface HTMLIrAutocompleteElementEventMap {
        "comboboxValue": { key: string; data: unknown };
        "inputCleared": null;
        "toast": IToast1;
    }
    interface HTMLIrAutocompleteElement extends Components.IrAutocomplete, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrAutocompleteElementEventMap>(type: K, listener: (this: HTMLIrAutocompleteElement, ev: IrAutocompleteCustomEvent<HTMLIrAutocompleteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrAutocompleteElementEventMap>(type: K, listener: (this: HTMLIrAutocompleteElement, ev: IrAutocompleteCustomEvent<HTMLIrAutocompleteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrAutocompleteElement: {
        prototype: HTMLIrAutocompleteElement;
        new (): HTMLIrAutocompleteElement;
    };
    interface HTMLIrBookingElement extends Components.IrBooking, HTMLStencilElement {
    }
    var HTMLIrBookingElement: {
        prototype: HTMLIrBookingElement;
        new (): HTMLIrBookingElement;
    };
    interface HTMLIrBookingDetailsElementEventMap {
        "toast": IToast;
        "bookingChanged": Booking;
        "closeSidebar": null;
    }
    interface HTMLIrBookingDetailsElement extends Components.IrBookingDetails, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrBookingDetailsElementEventMap>(type: K, listener: (this: HTMLIrBookingDetailsElement, ev: IrBookingDetailsCustomEvent<HTMLIrBookingDetailsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrBookingDetailsElementEventMap>(type: K, listener: (this: HTMLIrBookingDetailsElement, ev: IrBookingDetailsCustomEvent<HTMLIrBookingDetailsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrBookingDetailsElement: {
        prototype: HTMLIrBookingDetailsElement;
        new (): HTMLIrBookingDetailsElement;
    };
    interface HTMLIrBookingExtraNoteElementEventMap {
        "closeModal": null;
        "resetBookingEvt": Booking | null;
    }
    interface HTMLIrBookingExtraNoteElement extends Components.IrBookingExtraNote, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrBookingExtraNoteElementEventMap>(type: K, listener: (this: HTMLIrBookingExtraNoteElement, ev: IrBookingExtraNoteCustomEvent<HTMLIrBookingExtraNoteElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrBookingExtraNoteElementEventMap>(type: K, listener: (this: HTMLIrBookingExtraNoteElement, ev: IrBookingExtraNoteCustomEvent<HTMLIrBookingExtraNoteElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrBookingExtraNoteElement: {
        prototype: HTMLIrBookingExtraNoteElement;
        new (): HTMLIrBookingExtraNoteElement;
    };
    interface HTMLIrBookingHeaderElementEventMap {
        "toast": IToast;
        "closeSidebar": null;
        "resetBookingEvt": null;
        "openSidebar": OpenSidebarEvent<any>;
    }
    interface HTMLIrBookingHeaderElement extends Components.IrBookingHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrBookingHeaderElementEventMap>(type: K, listener: (this: HTMLIrBookingHeaderElement, ev: IrBookingHeaderCustomEvent<HTMLIrBookingHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrBookingHeaderElementEventMap>(type: K, listener: (this: HTMLIrBookingHeaderElement, ev: IrBookingHeaderCustomEvent<HTMLIrBookingHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrBookingHeaderElement: {
        prototype: HTMLIrBookingHeaderElement;
        new (): HTMLIrBookingHeaderElement;
    };
    interface HTMLIrBookingListingElement extends Components.IrBookingListing, HTMLStencilElement {
    }
    var HTMLIrBookingListingElement: {
        prototype: HTMLIrBookingListingElement;
        new (): HTMLIrBookingListingElement;
    };
    interface HTMLIrBookingPrintingElement extends Components.IrBookingPrinting, HTMLStencilElement {
    }
    var HTMLIrBookingPrintingElement: {
        prototype: HTMLIrBookingPrintingElement;
        new (): HTMLIrBookingPrintingElement;
    };
    interface HTMLIrButtonElementEventMap {
        "clickHandler": any;
    }
    interface HTMLIrButtonElement extends Components.IrButton, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrButtonElementEventMap>(type: K, listener: (this: HTMLIrButtonElement, ev: IrButtonCustomEvent<HTMLIrButtonElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrButtonElementEventMap>(type: K, listener: (this: HTMLIrButtonElement, ev: IrButtonCustomEvent<HTMLIrButtonElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrButtonElement: {
        prototype: HTMLIrButtonElement;
        new (): HTMLIrButtonElement;
    };
    interface HTMLIrChannelElement extends Components.IrChannel, HTMLStencilElement {
    }
    var HTMLIrChannelElement: {
        prototype: HTMLIrChannelElement;
        new (): HTMLIrChannelElement;
    };
    interface HTMLIrChannelEditorElementEventMap {
        "saveChannelFinished": null;
        "closeSideBar": null;
        "toast": IToast;
    }
    interface HTMLIrChannelEditorElement extends Components.IrChannelEditor, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrChannelEditorElementEventMap>(type: K, listener: (this: HTMLIrChannelEditorElement, ev: IrChannelEditorCustomEvent<HTMLIrChannelEditorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrChannelEditorElementEventMap>(type: K, listener: (this: HTMLIrChannelEditorElement, ev: IrChannelEditorCustomEvent<HTMLIrChannelEditorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrChannelEditorElement: {
        prototype: HTMLIrChannelEditorElement;
        new (): HTMLIrChannelEditorElement;
    };
    interface HTMLIrChannelGeneralElementEventMap {
        "connectionStatus": boolean;
    }
    interface HTMLIrChannelGeneralElement extends Components.IrChannelGeneral, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrChannelGeneralElementEventMap>(type: K, listener: (this: HTMLIrChannelGeneralElement, ev: IrChannelGeneralCustomEvent<HTMLIrChannelGeneralElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrChannelGeneralElementEventMap>(type: K, listener: (this: HTMLIrChannelGeneralElement, ev: IrChannelGeneralCustomEvent<HTMLIrChannelGeneralElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrChannelGeneralElement: {
        prototype: HTMLIrChannelGeneralElement;
        new (): HTMLIrChannelGeneralElement;
    };
    interface HTMLIrChannelHeaderElementEventMap {
        "tabChanged": string;
    }
    interface HTMLIrChannelHeaderElement extends Components.IrChannelHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrChannelHeaderElementEventMap>(type: K, listener: (this: HTMLIrChannelHeaderElement, ev: IrChannelHeaderCustomEvent<HTMLIrChannelHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrChannelHeaderElementEventMap>(type: K, listener: (this: HTMLIrChannelHeaderElement, ev: IrChannelHeaderCustomEvent<HTMLIrChannelHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrChannelHeaderElement: {
        prototype: HTMLIrChannelHeaderElement;
        new (): HTMLIrChannelHeaderElement;
    };
    interface HTMLIrChannelMappingElement extends Components.IrChannelMapping, HTMLStencilElement {
    }
    var HTMLIrChannelMappingElement: {
        prototype: HTMLIrChannelMappingElement;
        new (): HTMLIrChannelMappingElement;
    };
    interface HTMLIrCheckboxElementEventMap {
        "checkChange": boolean;
    }
    interface HTMLIrCheckboxElement extends Components.IrCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrCheckboxElementEventMap>(type: K, listener: (this: HTMLIrCheckboxElement, ev: IrCheckboxCustomEvent<HTMLIrCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrCheckboxElementEventMap>(type: K, listener: (this: HTMLIrCheckboxElement, ev: IrCheckboxCustomEvent<HTMLIrCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrCheckboxElement: {
        prototype: HTMLIrCheckboxElement;
        new (): HTMLIrCheckboxElement;
    };
    interface HTMLIrCheckboxesElementEventMap {
        "checkboxesChange": checkboxes[];
    }
    interface HTMLIrCheckboxesElement extends Components.IrCheckboxes, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrCheckboxesElementEventMap>(type: K, listener: (this: HTMLIrCheckboxesElement, ev: IrCheckboxesCustomEvent<HTMLIrCheckboxesElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrCheckboxesElementEventMap>(type: K, listener: (this: HTMLIrCheckboxesElement, ev: IrCheckboxesCustomEvent<HTMLIrCheckboxesElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrCheckboxesElement: {
        prototype: HTMLIrCheckboxesElement;
        new (): HTMLIrCheckboxesElement;
    };
    interface HTMLIrComboboxElementEventMap {
        "comboboxValueChange": { key: string; data: unknown };
        "inputCleared": null;
        "toast": IToast;
    }
    interface HTMLIrComboboxElement extends Components.IrCombobox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrComboboxElementEventMap>(type: K, listener: (this: HTMLIrComboboxElement, ev: IrComboboxCustomEvent<HTMLIrComboboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrComboboxElementEventMap>(type: K, listener: (this: HTMLIrComboboxElement, ev: IrComboboxCustomEvent<HTMLIrComboboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrComboboxElement: {
        prototype: HTMLIrComboboxElement;
        new (): HTMLIrComboboxElement;
    };
    interface HTMLIrCommonElement extends Components.IrCommon, HTMLStencilElement {
    }
    var HTMLIrCommonElement: {
        prototype: HTMLIrCommonElement;
        new (): HTMLIrCommonElement;
    };
    interface HTMLIrCountryPickerElementEventMap {
        "countryChange": ICountry;
    }
    interface HTMLIrCountryPickerElement extends Components.IrCountryPicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrCountryPickerElementEventMap>(type: K, listener: (this: HTMLIrCountryPickerElement, ev: IrCountryPickerCustomEvent<HTMLIrCountryPickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrCountryPickerElementEventMap>(type: K, listener: (this: HTMLIrCountryPickerElement, ev: IrCountryPickerCustomEvent<HTMLIrCountryPickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrCountryPickerElement: {
        prototype: HTMLIrCountryPickerElement;
        new (): HTMLIrCountryPickerElement;
    };
    interface HTMLIrDatePickerElementEventMap {
        "dateChanged": {
    start: moment.Moment;
    end: moment.Moment;
  };
        "datePickerFocus": void;
        "datePickerBlur": void;
    }
    interface HTMLIrDatePickerElement extends Components.IrDatePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrDatePickerElementEventMap>(type: K, listener: (this: HTMLIrDatePickerElement, ev: IrDatePickerCustomEvent<HTMLIrDatePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrDatePickerElementEventMap>(type: K, listener: (this: HTMLIrDatePickerElement, ev: IrDatePickerCustomEvent<HTMLIrDatePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrDatePickerElement: {
        prototype: HTMLIrDatePickerElement;
        new (): HTMLIrDatePickerElement;
    };
    interface HTMLIrDateRangeElementEventMap {
        "dateChanged": {
    start: moment.Moment;
    end: moment.Moment;
  };
    }
    interface HTMLIrDateRangeElement extends Components.IrDateRange, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrDateRangeElementEventMap>(type: K, listener: (this: HTMLIrDateRangeElement, ev: IrDateRangeCustomEvent<HTMLIrDateRangeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrDateRangeElementEventMap>(type: K, listener: (this: HTMLIrDateRangeElement, ev: IrDateRangeCustomEvent<HTMLIrDateRangeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrDateRangeElement: {
        prototype: HTMLIrDateRangeElement;
        new (): HTMLIrDateRangeElement;
    };
    interface HTMLIrDateViewElement extends Components.IrDateView, HTMLStencilElement {
    }
    var HTMLIrDateViewElement: {
        prototype: HTMLIrDateViewElement;
        new (): HTMLIrDateViewElement;
    };
    interface HTMLIrDeleteModalElementEventMap {
        "modalClosed": null;
        "resetData": string;
    }
    interface HTMLIrDeleteModalElement extends Components.IrDeleteModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrDeleteModalElementEventMap>(type: K, listener: (this: HTMLIrDeleteModalElement, ev: IrDeleteModalCustomEvent<HTMLIrDeleteModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrDeleteModalElementEventMap>(type: K, listener: (this: HTMLIrDeleteModalElement, ev: IrDeleteModalCustomEvent<HTMLIrDeleteModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrDeleteModalElement: {
        prototype: HTMLIrDeleteModalElement;
        new (): HTMLIrDeleteModalElement;
    };
    interface HTMLIrDialogElementEventMap {
        "openChange": boolean;
    }
    interface HTMLIrDialogElement extends Components.IrDialog, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrDialogElementEventMap>(type: K, listener: (this: HTMLIrDialogElement, ev: IrDialogCustomEvent<HTMLIrDialogElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrDialogElementEventMap>(type: K, listener: (this: HTMLIrDialogElement, ev: IrDialogCustomEvent<HTMLIrDialogElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrDialogElement: {
        prototype: HTMLIrDialogElement;
        new (): HTMLIrDialogElement;
    };
    interface HTMLIrDrawerElementEventMap {
        "drawerChange": boolean;
        "drawerCloseRequested": void;
    }
    interface HTMLIrDrawerElement extends Components.IrDrawer, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrDrawerElementEventMap>(type: K, listener: (this: HTMLIrDrawerElement, ev: IrDrawerCustomEvent<HTMLIrDrawerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrDrawerElementEventMap>(type: K, listener: (this: HTMLIrDrawerElement, ev: IrDrawerCustomEvent<HTMLIrDrawerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrDrawerElement: {
        prototype: HTMLIrDrawerElement;
        new (): HTMLIrDrawerElement;
    };
    interface HTMLIrDropdownElementEventMap {
        "dropdownItemCLicked": { name: string; object: any };
    }
    interface HTMLIrDropdownElement extends Components.IrDropdown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrDropdownElementEventMap>(type: K, listener: (this: HTMLIrDropdownElement, ev: IrDropdownCustomEvent<HTMLIrDropdownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrDropdownElementEventMap>(type: K, listener: (this: HTMLIrDropdownElement, ev: IrDropdownCustomEvent<HTMLIrDropdownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrDropdownElement: {
        prototype: HTMLIrDropdownElement;
        new (): HTMLIrDropdownElement;
    };
    interface HTMLIrEventsLogElement extends Components.IrEventsLog, HTMLStencilElement {
    }
    var HTMLIrEventsLogElement: {
        prototype: HTMLIrEventsLogElement;
        new (): HTMLIrEventsLogElement;
    };
    interface HTMLIrExtraServiceElementEventMap {
        "editExtraService": ExtraService;
        "resetBookingEvt": null;
    }
    interface HTMLIrExtraServiceElement extends Components.IrExtraService, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrExtraServiceElementEventMap>(type: K, listener: (this: HTMLIrExtraServiceElement, ev: IrExtraServiceCustomEvent<HTMLIrExtraServiceElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrExtraServiceElementEventMap>(type: K, listener: (this: HTMLIrExtraServiceElement, ev: IrExtraServiceCustomEvent<HTMLIrExtraServiceElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrExtraServiceElement: {
        prototype: HTMLIrExtraServiceElement;
        new (): HTMLIrExtraServiceElement;
    };
    interface HTMLIrExtraServiceConfigElementEventMap {
        "closeModal": null;
        "resetBookingEvt": null;
    }
    interface HTMLIrExtraServiceConfigElement extends Components.IrExtraServiceConfig, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrExtraServiceConfigElementEventMap>(type: K, listener: (this: HTMLIrExtraServiceConfigElement, ev: IrExtraServiceConfigCustomEvent<HTMLIrExtraServiceConfigElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrExtraServiceConfigElementEventMap>(type: K, listener: (this: HTMLIrExtraServiceConfigElement, ev: IrExtraServiceConfigCustomEvent<HTMLIrExtraServiceConfigElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrExtraServiceConfigElement: {
        prototype: HTMLIrExtraServiceConfigElement;
        new (): HTMLIrExtraServiceConfigElement;
    };
    interface HTMLIrExtraServicesElement extends Components.IrExtraServices, HTMLStencilElement {
    }
    var HTMLIrExtraServicesElement: {
        prototype: HTMLIrExtraServicesElement;
        new (): HTMLIrExtraServicesElement;
    };
    interface HTMLIrGuestInfoElementEventMap {
        "closeSideBar": null;
        "resetBookingEvt": null;
    }
    interface HTMLIrGuestInfoElement extends Components.IrGuestInfo, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrGuestInfoElementEventMap>(type: K, listener: (this: HTMLIrGuestInfoElement, ev: IrGuestInfoCustomEvent<HTMLIrGuestInfoElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrGuestInfoElementEventMap>(type: K, listener: (this: HTMLIrGuestInfoElement, ev: IrGuestInfoCustomEvent<HTMLIrGuestInfoElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrGuestInfoElement: {
        prototype: HTMLIrGuestInfoElement;
        new (): HTMLIrGuestInfoElement;
    };
    interface HTMLIrHkArchiveElement extends Components.IrHkArchive, HTMLStencilElement {
    }
    var HTMLIrHkArchiveElement: {
        prototype: HTMLIrHkArchiveElement;
        new (): HTMLIrHkArchiveElement;
    };
    interface HTMLIrHkTasksElementEventMap {
        "clearSelectedHkTasks": void;
    }
    interface HTMLIrHkTasksElement extends Components.IrHkTasks, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrHkTasksElementEventMap>(type: K, listener: (this: HTMLIrHkTasksElement, ev: IrHkTasksCustomEvent<HTMLIrHkTasksElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrHkTasksElementEventMap>(type: K, listener: (this: HTMLIrHkTasksElement, ev: IrHkTasksCustomEvent<HTMLIrHkTasksElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrHkTasksElement: {
        prototype: HTMLIrHkTasksElement;
        new (): HTMLIrHkTasksElement;
    };
    interface HTMLIrHkTeamElement extends Components.IrHkTeam, HTMLStencilElement {
    }
    var HTMLIrHkTeamElement: {
        prototype: HTMLIrHkTeamElement;
        new (): HTMLIrHkTeamElement;
    };
    interface HTMLIrHkUnassignedUnitsElementEventMap {
        "closeSideBar": null;
        "resetData": null;
    }
    interface HTMLIrHkUnassignedUnitsElement extends Components.IrHkUnassignedUnits, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrHkUnassignedUnitsElementEventMap>(type: K, listener: (this: HTMLIrHkUnassignedUnitsElement, ev: IrHkUnassignedUnitsCustomEvent<HTMLIrHkUnassignedUnitsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrHkUnassignedUnitsElementEventMap>(type: K, listener: (this: HTMLIrHkUnassignedUnitsElement, ev: IrHkUnassignedUnitsCustomEvent<HTMLIrHkUnassignedUnitsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrHkUnassignedUnitsElement: {
        prototype: HTMLIrHkUnassignedUnitsElement;
        new (): HTMLIrHkUnassignedUnitsElement;
    };
    interface HTMLIrHkUserElementEventMap {
        "resetData": null;
        "closeSideBar": null;
    }
    interface HTMLIrHkUserElement extends Components.IrHkUser, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrHkUserElementEventMap>(type: K, listener: (this: HTMLIrHkUserElement, ev: IrHkUserCustomEvent<HTMLIrHkUserElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrHkUserElementEventMap>(type: K, listener: (this: HTMLIrHkUserElement, ev: IrHkUserCustomEvent<HTMLIrHkUserElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrHkUserElement: {
        prototype: HTMLIrHkUserElement;
        new (): HTMLIrHkUserElement;
    };
    interface HTMLIrHousekeepingElementEventMap {
        "toast": IToast;
    }
    interface HTMLIrHousekeepingElement extends Components.IrHousekeeping, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrHousekeepingElementEventMap>(type: K, listener: (this: HTMLIrHousekeepingElement, ev: IrHousekeepingCustomEvent<HTMLIrHousekeepingElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrHousekeepingElementEventMap>(type: K, listener: (this: HTMLIrHousekeepingElement, ev: IrHousekeepingCustomEvent<HTMLIrHousekeepingElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrHousekeepingElement: {
        prototype: HTMLIrHousekeepingElement;
        new (): HTMLIrHousekeepingElement;
    };
    interface HTMLIrIconElementEventMap {
        "iconClickHandler": any;
    }
    interface HTMLIrIconElement extends Components.IrIcon, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrIconElementEventMap>(type: K, listener: (this: HTMLIrIconElement, ev: IrIconCustomEvent<HTMLIrIconElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrIconElementEventMap>(type: K, listener: (this: HTMLIrIconElement, ev: IrIconCustomEvent<HTMLIrIconElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrIconElement: {
        prototype: HTMLIrIconElement;
        new (): HTMLIrIconElement;
    };
    interface HTMLIrIconsElement extends Components.IrIcons, HTMLStencilElement {
    }
    var HTMLIrIconsElement: {
        prototype: HTMLIrIconsElement;
        new (): HTMLIrIconsElement;
    };
    interface HTMLIrInputTextElementEventMap {
        "textChange": any;
        "inputBlur": FocusEvent;
        "inputFocus": FocusEvent;
    }
    interface HTMLIrInputTextElement extends Components.IrInputText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrInputTextElementEventMap>(type: K, listener: (this: HTMLIrInputTextElement, ev: IrInputTextCustomEvent<HTMLIrInputTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrInputTextElementEventMap>(type: K, listener: (this: HTMLIrInputTextElement, ev: IrInputTextCustomEvent<HTMLIrInputTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrInputTextElement: {
        prototype: HTMLIrInputTextElement;
        new (): HTMLIrInputTextElement;
    };
    interface HTMLIrInteractiveTitleElement extends Components.IrInteractiveTitle, HTMLStencilElement {
    }
    var HTMLIrInteractiveTitleElement: {
        prototype: HTMLIrInteractiveTitleElement;
        new (): HTMLIrInteractiveTitleElement;
    };
    interface HTMLIrInterceptorElementEventMap {
        "toast": IToast;
    }
    interface HTMLIrInterceptorElement extends Components.IrInterceptor, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrInterceptorElementEventMap>(type: K, listener: (this: HTMLIrInterceptorElement, ev: IrInterceptorCustomEvent<HTMLIrInterceptorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrInterceptorElementEventMap>(type: K, listener: (this: HTMLIrInterceptorElement, ev: IrInterceptorCustomEvent<HTMLIrInterceptorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrInterceptorElement: {
        prototype: HTMLIrInterceptorElement;
        new (): HTMLIrInterceptorElement;
    };
    interface HTMLIrLabelElement extends Components.IrLabel, HTMLStencilElement {
    }
    var HTMLIrLabelElement: {
        prototype: HTMLIrLabelElement;
        new (): HTMLIrLabelElement;
    };
    interface HTMLIrListingHeaderElementEventMap {
        "preventPageLoad": string;
    }
    interface HTMLIrListingHeaderElement extends Components.IrListingHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrListingHeaderElementEventMap>(type: K, listener: (this: HTMLIrListingHeaderElement, ev: IrListingHeaderCustomEvent<HTMLIrListingHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrListingHeaderElementEventMap>(type: K, listener: (this: HTMLIrListingHeaderElement, ev: IrListingHeaderCustomEvent<HTMLIrListingHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrListingHeaderElement: {
        prototype: HTMLIrListingHeaderElement;
        new (): HTMLIrListingHeaderElement;
    };
    interface HTMLIrListingModalElementEventMap {
        "modalClosed": null;
        "resetData": string;
    }
    interface HTMLIrListingModalElement extends Components.IrListingModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrListingModalElementEventMap>(type: K, listener: (this: HTMLIrListingModalElement, ev: IrListingModalCustomEvent<HTMLIrListingModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrListingModalElementEventMap>(type: K, listener: (this: HTMLIrListingModalElement, ev: IrListingModalCustomEvent<HTMLIrListingModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrListingModalElement: {
        prototype: HTMLIrListingModalElement;
        new (): HTMLIrListingModalElement;
    };
    interface HTMLIrLoadingScreenElement extends Components.IrLoadingScreen, HTMLStencilElement {
    }
    var HTMLIrLoadingScreenElement: {
        prototype: HTMLIrLoadingScreenElement;
        new (): HTMLIrLoadingScreenElement;
    };
    interface HTMLIrLoginElementEventMap {
        "authFinish": {
    token: string;
    code: 'succsess' | 'error';
  };
    }
    interface HTMLIrLoginElement extends Components.IrLogin, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrLoginElementEventMap>(type: K, listener: (this: HTMLIrLoginElement, ev: IrLoginCustomEvent<HTMLIrLoginElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrLoginElementEventMap>(type: K, listener: (this: HTMLIrLoginElement, ev: IrLoginCustomEvent<HTMLIrLoginElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrLoginElement: {
        prototype: HTMLIrLoginElement;
        new (): HTMLIrLoginElement;
    };
    interface HTMLIrModalElementEventMap {
        "confirmModal": any;
        "cancelModal": any;
    }
    interface HTMLIrModalElement extends Components.IrModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrModalElementEventMap>(type: K, listener: (this: HTMLIrModalElement, ev: IrModalCustomEvent<HTMLIrModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrModalElementEventMap>(type: K, listener: (this: HTMLIrModalElement, ev: IrModalCustomEvent<HTMLIrModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrModalElement: {
        prototype: HTMLIrModalElement;
        new (): HTMLIrModalElement;
    };
    interface HTMLIrOptionDetailsElementEventMap {
        "closeModal": PaymentOption | null;
        "toast": IToast;
    }
    interface HTMLIrOptionDetailsElement extends Components.IrOptionDetails, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrOptionDetailsElementEventMap>(type: K, listener: (this: HTMLIrOptionDetailsElement, ev: IrOptionDetailsCustomEvent<HTMLIrOptionDetailsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrOptionDetailsElementEventMap>(type: K, listener: (this: HTMLIrOptionDetailsElement, ev: IrOptionDetailsCustomEvent<HTMLIrOptionDetailsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrOptionDetailsElement: {
        prototype: HTMLIrOptionDetailsElement;
        new (): HTMLIrOptionDetailsElement;
    };
    interface HTMLIrOtaServiceElement extends Components.IrOtaService, HTMLStencilElement {
    }
    var HTMLIrOtaServiceElement: {
        prototype: HTMLIrOtaServiceElement;
        new (): HTMLIrOtaServiceElement;
    };
    interface HTMLIrOtaServicesElement extends Components.IrOtaServices, HTMLStencilElement {
    }
    var HTMLIrOtaServicesElement: {
        prototype: HTMLIrOtaServicesElement;
        new (): HTMLIrOtaServicesElement;
    };
    interface HTMLIrOtpElementEventMap {
        "otpChange": string;
        "otpComplete": string;
    }
    interface HTMLIrOtpElement extends Components.IrOtp, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrOtpElementEventMap>(type: K, listener: (this: HTMLIrOtpElement, ev: IrOtpCustomEvent<HTMLIrOtpElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrOtpElementEventMap>(type: K, listener: (this: HTMLIrOtpElement, ev: IrOtpCustomEvent<HTMLIrOtpElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrOtpElement: {
        prototype: HTMLIrOtpElement;
        new (): HTMLIrOtpElement;
    };
    interface HTMLIrOtpModalElementEventMap {
        "otpFinished": {
    otp: string;
    type: 'success' | 'cancelled';
  };
    }
    interface HTMLIrOtpModalElement extends Components.IrOtpModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrOtpModalElementEventMap>(type: K, listener: (this: HTMLIrOtpModalElement, ev: IrOtpModalCustomEvent<HTMLIrOtpModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrOtpModalElementEventMap>(type: K, listener: (this: HTMLIrOtpModalElement, ev: IrOtpModalCustomEvent<HTMLIrOtpModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrOtpModalElement: {
        prototype: HTMLIrOtpModalElement;
        new (): HTMLIrOtpModalElement;
    };
    interface HTMLIrPasswordValidatorElementEventMap {
        "passwordValidationChange": boolean;
    }
    interface HTMLIrPasswordValidatorElement extends Components.IrPasswordValidator, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPasswordValidatorElementEventMap>(type: K, listener: (this: HTMLIrPasswordValidatorElement, ev: IrPasswordValidatorCustomEvent<HTMLIrPasswordValidatorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPasswordValidatorElementEventMap>(type: K, listener: (this: HTMLIrPasswordValidatorElement, ev: IrPasswordValidatorCustomEvent<HTMLIrPasswordValidatorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPasswordValidatorElement: {
        prototype: HTMLIrPasswordValidatorElement;
        new (): HTMLIrPasswordValidatorElement;
    };
    interface HTMLIrPaymentActionsElementEventMap {
        "generatePayment": IPaymentAction;
    }
    interface HTMLIrPaymentActionsElement extends Components.IrPaymentActions, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPaymentActionsElementEventMap>(type: K, listener: (this: HTMLIrPaymentActionsElement, ev: IrPaymentActionsCustomEvent<HTMLIrPaymentActionsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPaymentActionsElementEventMap>(type: K, listener: (this: HTMLIrPaymentActionsElement, ev: IrPaymentActionsCustomEvent<HTMLIrPaymentActionsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPaymentActionsElement: {
        prototype: HTMLIrPaymentActionsElement;
        new (): HTMLIrPaymentActionsElement;
    };
    interface HTMLIrPaymentDetailsElementEventMap {
        "resetBookingEvt": null;
        "resetExposedCancelationDueAmount": null;
        "toast": IToast;
    }
    interface HTMLIrPaymentDetailsElement extends Components.IrPaymentDetails, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPaymentDetailsElementEventMap>(type: K, listener: (this: HTMLIrPaymentDetailsElement, ev: IrPaymentDetailsCustomEvent<HTMLIrPaymentDetailsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPaymentDetailsElementEventMap>(type: K, listener: (this: HTMLIrPaymentDetailsElement, ev: IrPaymentDetailsCustomEvent<HTMLIrPaymentDetailsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPaymentDetailsElement: {
        prototype: HTMLIrPaymentDetailsElement;
        new (): HTMLIrPaymentDetailsElement;
    };
    interface HTMLIrPaymentOptionElementEventMap {
        "toast": IToast;
    }
    interface HTMLIrPaymentOptionElement extends Components.IrPaymentOption, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPaymentOptionElementEventMap>(type: K, listener: (this: HTMLIrPaymentOptionElement, ev: IrPaymentOptionCustomEvent<HTMLIrPaymentOptionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPaymentOptionElementEventMap>(type: K, listener: (this: HTMLIrPaymentOptionElement, ev: IrPaymentOptionCustomEvent<HTMLIrPaymentOptionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPaymentOptionElement: {
        prototype: HTMLIrPaymentOptionElement;
        new (): HTMLIrPaymentOptionElement;
    };
    interface HTMLIrPhoneInputElementEventMap {
        "textChange": { phone_prefix: string; mobile: string };
    }
    interface HTMLIrPhoneInputElement extends Components.IrPhoneInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPhoneInputElementEventMap>(type: K, listener: (this: HTMLIrPhoneInputElement, ev: IrPhoneInputCustomEvent<HTMLIrPhoneInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPhoneInputElementEventMap>(type: K, listener: (this: HTMLIrPhoneInputElement, ev: IrPhoneInputCustomEvent<HTMLIrPhoneInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPhoneInputElement: {
        prototype: HTMLIrPhoneInputElement;
        new (): HTMLIrPhoneInputElement;
    };
    interface HTMLIrPickupElementEventMap {
        "closeModal": null;
        "resetBookingEvt": null;
    }
    interface HTMLIrPickupElement extends Components.IrPickup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPickupElementEventMap>(type: K, listener: (this: HTMLIrPickupElement, ev: IrPickupCustomEvent<HTMLIrPickupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPickupElementEventMap>(type: K, listener: (this: HTMLIrPickupElement, ev: IrPickupCustomEvent<HTMLIrPickupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPickupElement: {
        prototype: HTMLIrPickupElement;
        new (): HTMLIrPickupElement;
    };
    interface HTMLIrPickupViewElement extends Components.IrPickupView, HTMLStencilElement {
    }
    var HTMLIrPickupViewElement: {
        prototype: HTMLIrPickupViewElement;
        new (): HTMLIrPickupViewElement;
    };
    interface HTMLIrPmsLogsElement extends Components.IrPmsLogs, HTMLStencilElement {
    }
    var HTMLIrPmsLogsElement: {
        prototype: HTMLIrPmsLogsElement;
        new (): HTMLIrPmsLogsElement;
    };
    interface HTMLIrPopoverElement extends Components.IrPopover, HTMLStencilElement {
    }
    var HTMLIrPopoverElement: {
        prototype: HTMLIrPopoverElement;
        new (): HTMLIrPopoverElement;
    };
    interface HTMLIrPriceInputElementEventMap {
        "textChange": string;
        "inputBlur": string;
        "inputFocus": void;
    }
    interface HTMLIrPriceInputElement extends Components.IrPriceInput, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrPriceInputElementEventMap>(type: K, listener: (this: HTMLIrPriceInputElement, ev: IrPriceInputCustomEvent<HTMLIrPriceInputElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrPriceInputElementEventMap>(type: K, listener: (this: HTMLIrPriceInputElement, ev: IrPriceInputCustomEvent<HTMLIrPriceInputElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrPriceInputElement: {
        prototype: HTMLIrPriceInputElement;
        new (): HTMLIrPriceInputElement;
    };
    interface HTMLIrRadioElementEventMap {
        "checkChange": boolean;
    }
    interface HTMLIrRadioElement extends Components.IrRadio, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrRadioElementEventMap>(type: K, listener: (this: HTMLIrRadioElement, ev: IrRadioCustomEvent<HTMLIrRadioElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrRadioElementEventMap>(type: K, listener: (this: HTMLIrRadioElement, ev: IrRadioCustomEvent<HTMLIrRadioElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrRadioElement: {
        prototype: HTMLIrRadioElement;
        new (): HTMLIrRadioElement;
    };
    interface HTMLIrRangePickerElementEventMap {
        "dateRangeChanged": { fromDate: Moment; toDate: Moment };
    }
    interface HTMLIrRangePickerElement extends Components.IrRangePicker, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrRangePickerElementEventMap>(type: K, listener: (this: HTMLIrRangePickerElement, ev: IrRangePickerCustomEvent<HTMLIrRangePickerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrRangePickerElementEventMap>(type: K, listener: (this: HTMLIrRangePickerElement, ev: IrRangePickerCustomEvent<HTMLIrRangePickerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrRangePickerElement: {
        prototype: HTMLIrRangePickerElement;
        new (): HTMLIrRangePickerElement;
    };
    interface HTMLIrReservationInformationElementEventMap {
        "openSidebar": OpenSidebarEvent<any>;
    }
    interface HTMLIrReservationInformationElement extends Components.IrReservationInformation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrReservationInformationElementEventMap>(type: K, listener: (this: HTMLIrReservationInformationElement, ev: IrReservationInformationCustomEvent<HTMLIrReservationInformationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrReservationInformationElementEventMap>(type: K, listener: (this: HTMLIrReservationInformationElement, ev: IrReservationInformationCustomEvent<HTMLIrReservationInformationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrReservationInformationElement: {
        prototype: HTMLIrReservationInformationElement;
        new (): HTMLIrReservationInformationElement;
    };
    interface HTMLIrResetPasswordElementEventMap {
        "closeSideBar": null;
    }
    interface HTMLIrResetPasswordElement extends Components.IrResetPassword, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrResetPasswordElementEventMap>(type: K, listener: (this: HTMLIrResetPasswordElement, ev: IrResetPasswordCustomEvent<HTMLIrResetPasswordElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrResetPasswordElementEventMap>(type: K, listener: (this: HTMLIrResetPasswordElement, ev: IrResetPasswordCustomEvent<HTMLIrResetPasswordElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrResetPasswordElement: {
        prototype: HTMLIrResetPasswordElement;
        new (): HTMLIrResetPasswordElement;
    };
    interface HTMLIrRoomElementEventMap {
        "deleteFinished": string;
        "pressCheckIn": any;
        "pressCheckOut": any;
        "editInitiated": TIglBookPropertyPayload;
    }
    interface HTMLIrRoomElement extends Components.IrRoom, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrRoomElementEventMap>(type: K, listener: (this: HTMLIrRoomElement, ev: IrRoomCustomEvent<HTMLIrRoomElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrRoomElementEventMap>(type: K, listener: (this: HTMLIrRoomElement, ev: IrRoomCustomEvent<HTMLIrRoomElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrRoomElement: {
        prototype: HTMLIrRoomElement;
        new (): HTMLIrRoomElement;
    };
    interface HTMLIrRoomGuestsElementEventMap {
        "closeModal": null;
        "resetBookingEvt": null;
        "updateRoomGuests": { identifier: string; guests: SharedPerson[] };
    }
    interface HTMLIrRoomGuestsElement extends Components.IrRoomGuests, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrRoomGuestsElementEventMap>(type: K, listener: (this: HTMLIrRoomGuestsElement, ev: IrRoomGuestsCustomEvent<HTMLIrRoomGuestsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrRoomGuestsElementEventMap>(type: K, listener: (this: HTMLIrRoomGuestsElement, ev: IrRoomGuestsCustomEvent<HTMLIrRoomGuestsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrRoomGuestsElement: {
        prototype: HTMLIrRoomGuestsElement;
        new (): HTMLIrRoomGuestsElement;
    };
    interface HTMLIrRoomNightsElementEventMap {
        "closeRoomNightsDialog": IRoomNightsDataEventPayload;
    }
    interface HTMLIrRoomNightsElement extends Components.IrRoomNights, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrRoomNightsElementEventMap>(type: K, listener: (this: HTMLIrRoomNightsElement, ev: IrRoomNightsCustomEvent<HTMLIrRoomNightsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrRoomNightsElementEventMap>(type: K, listener: (this: HTMLIrRoomNightsElement, ev: IrRoomNightsCustomEvent<HTMLIrRoomNightsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrRoomNightsElement: {
        prototype: HTMLIrRoomNightsElement;
        new (): HTMLIrRoomNightsElement;
    };
    interface HTMLIrSalesByCountryElement extends Components.IrSalesByCountry, HTMLStencilElement {
    }
    var HTMLIrSalesByCountryElement: {
        prototype: HTMLIrSalesByCountryElement;
        new (): HTMLIrSalesByCountryElement;
    };
    interface HTMLIrSalesFiltersElementEventMap {
        "applyFilters": SalesFilters;
    }
    interface HTMLIrSalesFiltersElement extends Components.IrSalesFilters, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrSalesFiltersElementEventMap>(type: K, listener: (this: HTMLIrSalesFiltersElement, ev: IrSalesFiltersCustomEvent<HTMLIrSalesFiltersElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrSalesFiltersElementEventMap>(type: K, listener: (this: HTMLIrSalesFiltersElement, ev: IrSalesFiltersCustomEvent<HTMLIrSalesFiltersElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrSalesFiltersElement: {
        prototype: HTMLIrSalesFiltersElement;
        new (): HTMLIrSalesFiltersElement;
    };
    interface HTMLIrSalesTableElement extends Components.IrSalesTable, HTMLStencilElement {
    }
    var HTMLIrSalesTableElement: {
        prototype: HTMLIrSalesTableElement;
        new (): HTMLIrSalesTableElement;
    };
    interface HTMLIrSecureTasksElement extends Components.IrSecureTasks, HTMLStencilElement {
    }
    var HTMLIrSecureTasksElement: {
        prototype: HTMLIrSecureTasksElement;
        new (): HTMLIrSecureTasksElement;
    };
    interface HTMLIrSelectElementEventMap {
        "selectChange": any;
    }
    interface HTMLIrSelectElement extends Components.IrSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrSelectElementEventMap>(type: K, listener: (this: HTMLIrSelectElement, ev: IrSelectCustomEvent<HTMLIrSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrSelectElementEventMap>(type: K, listener: (this: HTMLIrSelectElement, ev: IrSelectCustomEvent<HTMLIrSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrSelectElement: {
        prototype: HTMLIrSelectElement;
        new (): HTMLIrSelectElement;
    };
    interface HTMLIrSidebarElementEventMap {
        "irSidebarToggle": any;
        "beforeSidebarClose": any;
    }
    interface HTMLIrSidebarElement extends Components.IrSidebar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrSidebarElementEventMap>(type: K, listener: (this: HTMLIrSidebarElement, ev: IrSidebarCustomEvent<HTMLIrSidebarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrSidebarElementEventMap>(type: K, listener: (this: HTMLIrSidebarElement, ev: IrSidebarCustomEvent<HTMLIrSidebarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrSidebarElement: {
        prototype: HTMLIrSidebarElement;
        new (): HTMLIrSidebarElement;
    };
    interface HTMLIrSpanElement extends Components.IrSpan, HTMLStencilElement {
    }
    var HTMLIrSpanElement: {
        prototype: HTMLIrSpanElement;
        new (): HTMLIrSpanElement;
    };
    interface HTMLIrSpinnerElement extends Components.IrSpinner, HTMLStencilElement {
    }
    var HTMLIrSpinnerElement: {
        prototype: HTMLIrSpinnerElement;
        new (): HTMLIrSpinnerElement;
    };
    interface HTMLIrSwitchElementEventMap {
        "checkChange": boolean;
    }
    interface HTMLIrSwitchElement extends Components.IrSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrSwitchElementEventMap>(type: K, listener: (this: HTMLIrSwitchElement, ev: IrSwitchCustomEvent<HTMLIrSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrSwitchElementEventMap>(type: K, listener: (this: HTMLIrSwitchElement, ev: IrSwitchCustomEvent<HTMLIrSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrSwitchElement: {
        prototype: HTMLIrSwitchElement;
        new (): HTMLIrSwitchElement;
    };
    interface HTMLIrTasksFiltersElementEventMap {
        "applyFilters": TaskFilters;
    }
    interface HTMLIrTasksFiltersElement extends Components.IrTasksFilters, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrTasksFiltersElementEventMap>(type: K, listener: (this: HTMLIrTasksFiltersElement, ev: IrTasksFiltersCustomEvent<HTMLIrTasksFiltersElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrTasksFiltersElementEventMap>(type: K, listener: (this: HTMLIrTasksFiltersElement, ev: IrTasksFiltersCustomEvent<HTMLIrTasksFiltersElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrTasksFiltersElement: {
        prototype: HTMLIrTasksFiltersElement;
        new (): HTMLIrTasksFiltersElement;
    };
    interface HTMLIrTasksHeaderElementEventMap {
        "headerButtonPress": { name: 'cleaned' | 'export' | 'archive' };
    }
    interface HTMLIrTasksHeaderElement extends Components.IrTasksHeader, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrTasksHeaderElementEventMap>(type: K, listener: (this: HTMLIrTasksHeaderElement, ev: IrTasksHeaderCustomEvent<HTMLIrTasksHeaderElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrTasksHeaderElementEventMap>(type: K, listener: (this: HTMLIrTasksHeaderElement, ev: IrTasksHeaderCustomEvent<HTMLIrTasksHeaderElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrTasksHeaderElement: {
        prototype: HTMLIrTasksHeaderElement;
        new (): HTMLIrTasksHeaderElement;
    };
    interface HTMLIrTasksTableElementEventMap {
        "animateCleanedButton": null;
        "rowSelectChange": Task[];
        "sortingChanged": { field: string; direction: 'ASC' | 'DESC' };
    }
    interface HTMLIrTasksTableElement extends Components.IrTasksTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrTasksTableElementEventMap>(type: K, listener: (this: HTMLIrTasksTableElement, ev: IrTasksTableCustomEvent<HTMLIrTasksTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrTasksTableElementEventMap>(type: K, listener: (this: HTMLIrTasksTableElement, ev: IrTasksTableCustomEvent<HTMLIrTasksTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrTasksTableElement: {
        prototype: HTMLIrTasksTableElement;
        new (): HTMLIrTasksTableElement;
    };
    interface HTMLIrTestCmpElement extends Components.IrTestCmp, HTMLStencilElement {
    }
    var HTMLIrTestCmpElement: {
        prototype: HTMLIrTestCmpElement;
        new (): HTMLIrTestCmpElement;
    };
    interface HTMLIrTextEditorElementEventMap {
        "textChange": string;
    }
    interface HTMLIrTextEditorElement extends Components.IrTextEditor, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrTextEditorElementEventMap>(type: K, listener: (this: HTMLIrTextEditorElement, ev: IrTextEditorCustomEvent<HTMLIrTextEditorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrTextEditorElementEventMap>(type: K, listener: (this: HTMLIrTextEditorElement, ev: IrTextEditorCustomEvent<HTMLIrTextEditorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrTextEditorElement: {
        prototype: HTMLIrTextEditorElement;
        new (): HTMLIrTextEditorElement;
    };
    interface HTMLIrTextareaElementEventMap {
        "textChange": string;
    }
    interface HTMLIrTextareaElement extends Components.IrTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrTextareaElementEventMap>(type: K, listener: (this: HTMLIrTextareaElement, ev: IrTextareaCustomEvent<HTMLIrTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrTextareaElementEventMap>(type: K, listener: (this: HTMLIrTextareaElement, ev: IrTextareaCustomEvent<HTMLIrTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrTextareaElement: {
        prototype: HTMLIrTextareaElement;
        new (): HTMLIrTextareaElement;
    };
    interface HTMLIrTitleElementEventMap {
        "closeSideBar": null;
    }
    interface HTMLIrTitleElement extends Components.IrTitle, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrTitleElementEventMap>(type: K, listener: (this: HTMLIrTitleElement, ev: IrTitleCustomEvent<HTMLIrTitleElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrTitleElementEventMap>(type: K, listener: (this: HTMLIrTitleElement, ev: IrTitleCustomEvent<HTMLIrTitleElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrTitleElement: {
        prototype: HTMLIrTitleElement;
        new (): HTMLIrTitleElement;
    };
    interface HTMLIrToastElement extends Components.IrToast, HTMLStencilElement {
    }
    var HTMLIrToastElement: {
        prototype: HTMLIrToastElement;
        new (): HTMLIrToastElement;
    };
    interface HTMLIrTooltipElement extends Components.IrTooltip, HTMLStencilElement {
    }
    var HTMLIrTooltipElement: {
        prototype: HTMLIrTooltipElement;
        new (): HTMLIrTooltipElement;
    };
    interface HTMLIrUnitStatusElementEventMap {
        "resetData": null;
    }
    interface HTMLIrUnitStatusElement extends Components.IrUnitStatus, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrUnitStatusElementEventMap>(type: K, listener: (this: HTMLIrUnitStatusElement, ev: IrUnitStatusCustomEvent<HTMLIrUnitStatusElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrUnitStatusElementEventMap>(type: K, listener: (this: HTMLIrUnitStatusElement, ev: IrUnitStatusCustomEvent<HTMLIrUnitStatusElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrUnitStatusElement: {
        prototype: HTMLIrUnitStatusElement;
        new (): HTMLIrUnitStatusElement;
    };
    interface HTMLIrUserFormPanelElementEventMap {
        "resetData": null;
        "closeSideBar": null;
    }
    interface HTMLIrUserFormPanelElement extends Components.IrUserFormPanel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrUserFormPanelElementEventMap>(type: K, listener: (this: HTMLIrUserFormPanelElement, ev: IrUserFormPanelCustomEvent<HTMLIrUserFormPanelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrUserFormPanelElementEventMap>(type: K, listener: (this: HTMLIrUserFormPanelElement, ev: IrUserFormPanelCustomEvent<HTMLIrUserFormPanelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrUserFormPanelElement: {
        prototype: HTMLIrUserFormPanelElement;
        new (): HTMLIrUserFormPanelElement;
    };
    interface HTMLIrUserManagementElement extends Components.IrUserManagement, HTMLStencilElement {
    }
    var HTMLIrUserManagementElement: {
        prototype: HTMLIrUserManagementElement;
        new (): HTMLIrUserManagementElement;
    };
    interface HTMLIrUserManagementTableElementEventMap {
        "toast": IToast;
        "resetData": null;
    }
    interface HTMLIrUserManagementTableElement extends Components.IrUserManagementTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrUserManagementTableElementEventMap>(type: K, listener: (this: HTMLIrUserManagementTableElement, ev: IrUserManagementTableCustomEvent<HTMLIrUserManagementTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrUserManagementTableElementEventMap>(type: K, listener: (this: HTMLIrUserManagementTableElement, ev: IrUserManagementTableCustomEvent<HTMLIrUserManagementTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrUserManagementTableElement: {
        prototype: HTMLIrUserManagementTableElement;
        new (): HTMLIrUserManagementTableElement;
    };
    interface HTMLIrWeekdaySelectorElementEventMap {
        "weekdayChange": number[];
    }
    interface HTMLIrWeekdaySelectorElement extends Components.IrWeekdaySelector, HTMLStencilElement {
        addEventListener<K extends keyof HTMLIrWeekdaySelectorElementEventMap>(type: K, listener: (this: HTMLIrWeekdaySelectorElement, ev: IrWeekdaySelectorCustomEvent<HTMLIrWeekdaySelectorElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLIrWeekdaySelectorElementEventMap>(type: K, listener: (this: HTMLIrWeekdaySelectorElement, ev: IrWeekdaySelectorCustomEvent<HTMLIrWeekdaySelectorElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLIrWeekdaySelectorElement: {
        prototype: HTMLIrWeekdaySelectorElement;
        new (): HTMLIrWeekdaySelectorElement;
    };
    interface HTMLOtaLabelElement extends Components.OtaLabel, HTMLStencilElement {
    }
    var HTMLOtaLabelElement: {
        prototype: HTMLOtaLabelElement;
        new (): HTMLOtaLabelElement;
    };
    interface HTMLRequirementCheckElement extends Components.RequirementCheck, HTMLStencilElement {
    }
    var HTMLRequirementCheckElement: {
        prototype: HTMLRequirementCheckElement;
        new (): HTMLRequirementCheckElement;
    };
    interface HTMLElementTagNameMap {
        "igl-application-info": HTMLIglApplicationInfoElement;
        "igl-block-dates-view": HTMLIglBlockDatesViewElement;
        "igl-book-property": HTMLIglBookPropertyElement;
        "igl-book-property-container": HTMLIglBookPropertyContainerElement;
        "igl-book-property-footer": HTMLIglBookPropertyFooterElement;
        "igl-book-property-header": HTMLIglBookPropertyHeaderElement;
        "igl-booking-event": HTMLIglBookingEventElement;
        "igl-booking-event-hover": HTMLIglBookingEventHoverElement;
        "igl-booking-form": HTMLIglBookingFormElement;
        "igl-booking-overview-page": HTMLIglBookingOverviewPageElement;
        "igl-bulk-stop-sale": HTMLIglBulkStopSaleElement;
        "igl-cal-body": HTMLIglCalBodyElement;
        "igl-cal-footer": HTMLIglCalFooterElement;
        "igl-cal-header": HTMLIglCalHeaderElement;
        "igl-date-range": HTMLIglDateRangeElement;
        "igl-legends": HTMLIglLegendsElement;
        "igl-property-booked-by": HTMLIglPropertyBookedByElement;
        "igl-rate-plan": HTMLIglRatePlanElement;
        "igl-room-type": HTMLIglRoomTypeElement;
        "igl-tba-booking-view": HTMLIglTbaBookingViewElement;
        "igl-tba-category-view": HTMLIglTbaCategoryViewElement;
        "igl-to-be-assigned": HTMLIglToBeAssignedElement;
        "igloo-calendar": HTMLIglooCalendarElement;
        "ir-autocomplete": HTMLIrAutocompleteElement;
        "ir-booking": HTMLIrBookingElement;
        "ir-booking-details": HTMLIrBookingDetailsElement;
        "ir-booking-extra-note": HTMLIrBookingExtraNoteElement;
        "ir-booking-header": HTMLIrBookingHeaderElement;
        "ir-booking-listing": HTMLIrBookingListingElement;
        "ir-booking-printing": HTMLIrBookingPrintingElement;
        "ir-button": HTMLIrButtonElement;
        "ir-channel": HTMLIrChannelElement;
        "ir-channel-editor": HTMLIrChannelEditorElement;
        "ir-channel-general": HTMLIrChannelGeneralElement;
        "ir-channel-header": HTMLIrChannelHeaderElement;
        "ir-channel-mapping": HTMLIrChannelMappingElement;
        "ir-checkbox": HTMLIrCheckboxElement;
        "ir-checkboxes": HTMLIrCheckboxesElement;
        "ir-combobox": HTMLIrComboboxElement;
        "ir-common": HTMLIrCommonElement;
        "ir-country-picker": HTMLIrCountryPickerElement;
        "ir-date-picker": HTMLIrDatePickerElement;
        "ir-date-range": HTMLIrDateRangeElement;
        "ir-date-view": HTMLIrDateViewElement;
        "ir-delete-modal": HTMLIrDeleteModalElement;
        "ir-dialog": HTMLIrDialogElement;
        "ir-drawer": HTMLIrDrawerElement;
        "ir-dropdown": HTMLIrDropdownElement;
        "ir-events-log": HTMLIrEventsLogElement;
        "ir-extra-service": HTMLIrExtraServiceElement;
        "ir-extra-service-config": HTMLIrExtraServiceConfigElement;
        "ir-extra-services": HTMLIrExtraServicesElement;
        "ir-guest-info": HTMLIrGuestInfoElement;
        "ir-hk-archive": HTMLIrHkArchiveElement;
        "ir-hk-tasks": HTMLIrHkTasksElement;
        "ir-hk-team": HTMLIrHkTeamElement;
        "ir-hk-unassigned-units": HTMLIrHkUnassignedUnitsElement;
        "ir-hk-user": HTMLIrHkUserElement;
        "ir-housekeeping": HTMLIrHousekeepingElement;
        "ir-icon": HTMLIrIconElement;
        "ir-icons": HTMLIrIconsElement;
        "ir-input-text": HTMLIrInputTextElement;
        "ir-interactive-title": HTMLIrInteractiveTitleElement;
        "ir-interceptor": HTMLIrInterceptorElement;
        "ir-label": HTMLIrLabelElement;
        "ir-listing-header": HTMLIrListingHeaderElement;
        "ir-listing-modal": HTMLIrListingModalElement;
        "ir-loading-screen": HTMLIrLoadingScreenElement;
        "ir-login": HTMLIrLoginElement;
        "ir-modal": HTMLIrModalElement;
        "ir-option-details": HTMLIrOptionDetailsElement;
        "ir-ota-service": HTMLIrOtaServiceElement;
        "ir-ota-services": HTMLIrOtaServicesElement;
        "ir-otp": HTMLIrOtpElement;
        "ir-otp-modal": HTMLIrOtpModalElement;
        "ir-password-validator": HTMLIrPasswordValidatorElement;
        "ir-payment-actions": HTMLIrPaymentActionsElement;
        "ir-payment-details": HTMLIrPaymentDetailsElement;
        "ir-payment-option": HTMLIrPaymentOptionElement;
        "ir-phone-input": HTMLIrPhoneInputElement;
        "ir-pickup": HTMLIrPickupElement;
        "ir-pickup-view": HTMLIrPickupViewElement;
        "ir-pms-logs": HTMLIrPmsLogsElement;
        "ir-popover": HTMLIrPopoverElement;
        "ir-price-input": HTMLIrPriceInputElement;
        "ir-radio": HTMLIrRadioElement;
        "ir-range-picker": HTMLIrRangePickerElement;
        "ir-reservation-information": HTMLIrReservationInformationElement;
        "ir-reset-password": HTMLIrResetPasswordElement;
        "ir-room": HTMLIrRoomElement;
        "ir-room-guests": HTMLIrRoomGuestsElement;
        "ir-room-nights": HTMLIrRoomNightsElement;
        "ir-sales-by-country": HTMLIrSalesByCountryElement;
        "ir-sales-filters": HTMLIrSalesFiltersElement;
        "ir-sales-table": HTMLIrSalesTableElement;
        "ir-secure-tasks": HTMLIrSecureTasksElement;
        "ir-select": HTMLIrSelectElement;
        "ir-sidebar": HTMLIrSidebarElement;
        "ir-span": HTMLIrSpanElement;
        "ir-spinner": HTMLIrSpinnerElement;
        "ir-switch": HTMLIrSwitchElement;
        "ir-tasks-filters": HTMLIrTasksFiltersElement;
        "ir-tasks-header": HTMLIrTasksHeaderElement;
        "ir-tasks-table": HTMLIrTasksTableElement;
        "ir-test-cmp": HTMLIrTestCmpElement;
        "ir-text-editor": HTMLIrTextEditorElement;
        "ir-textarea": HTMLIrTextareaElement;
        "ir-title": HTMLIrTitleElement;
        "ir-toast": HTMLIrToastElement;
        "ir-tooltip": HTMLIrTooltipElement;
        "ir-unit-status": HTMLIrUnitStatusElement;
        "ir-user-form-panel": HTMLIrUserFormPanelElement;
        "ir-user-management": HTMLIrUserManagementElement;
        "ir-user-management-table": HTMLIrUserManagementTableElement;
        "ir-weekday-selector": HTMLIrWeekdaySelectorElement;
        "ota-label": HTMLOtaLabelElement;
        "requirement-check": HTMLRequirementCheckElement;
    }
}
declare namespace LocalJSX {
    interface IglApplicationInfo {
        "baseData"?: { unit: { id: string; name: string }; roomtypeId: number };
        "bedPreferenceType"?: any[];
        "bookingType"?: string;
        "currency"?: ICurrency;
        "guestInfo"?: RatePlanGuest | null;
        "rateplanSelection"?: IRatePlanSelection;
        "roomIndex"?: number;
        "totalNights"?: number;
    }
    interface IglBlockDatesView {
        "defaultData"?: { [key: string]: any };
        "entryDate"?: string;
        "entryHour"?: number;
        "entryMinute"?: number;
        "fromDate"?: string;
        "isEventHover"?: boolean;
        "onDataUpdateEvent"?: (event: IglBlockDatesViewCustomEvent<{ [key: string]: any }>) => void;
        "toDate"?: string;
    }
    interface IglBookProperty {
        "adultChildConstraints"?: TAdultChildConstraints;
        "allowedBookingSources"?: any;
        "bookingData"?: { [key: string]: any };
        "countries"?: ICountry[];
        "currency"?: ICurrency;
        "language"?: string;
        "onAnimateIrButton"?: (event: IglBookPropertyCustomEvent<string>) => void;
        "onAnimateIrSelect"?: (event: IglBookPropertyCustomEvent<string>) => void;
        "onBlockedCreated"?: (event: IglBookPropertyCustomEvent<RoomBlockDetails>) => void;
        "onCloseBookingWindow"?: (event: IglBookPropertyCustomEvent<{ [key: string]: any }>) => void;
        "onResetBookingEvt"?: (event: IglBookPropertyCustomEvent<null>) => void;
        "onToast"?: (event: IglBookPropertyCustomEvent<IToast>) => void;
        "propertyid"?: number;
        "showPaymentDetails"?: boolean;
    }
    interface IglBookPropertyContainer {
        "from_date"?: string;
        "language"?: string;
        "onResetBookingData"?: (event: IglBookPropertyContainerCustomEvent<null>) => void;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
        "to_date"?: string;
        "withIrToastAndInterceptor"?: boolean;
    }
    interface IglBookPropertyFooter {
        "dateRangeData"?: { [key: string]: any };
        "disabled"?: boolean;
        "eventType"?: string;
        "isEditOrAddRoomEvent"?: boolean;
        "isLoading"?: string;
        "onButtonClicked"?: (event: IglBookPropertyFooterCustomEvent<{ key: TPropertyButtonsTypes }>) => void;
        "page"?: string;
    }
    interface IglBookPropertyHeader {
        "adultChildConstraints"?: TAdultChildConstraints1;
        "adultChildCount"?: { adult: number; child: number };
        "bookedByInfoData"?: any;
        "bookingData"?: any;
        "bookingDataDefaultDateRange"?: { [key: string]: any };
        "dateRangeData"?: any;
        "defaultDaterange"?: { from_date: string; to_date: string };
        "message"?: string;
        "minDate"?: string;
        "onAdultChild"?: (event: IglBookPropertyHeaderCustomEvent<any>) => void;
        "onAnimateIrButton"?: (event: IglBookPropertyHeaderCustomEvent<string>) => void;
        "onAnimateIrSelect"?: (event: IglBookPropertyHeaderCustomEvent<string>) => void;
        "onButtonClicked"?: (event: IglBookPropertyHeaderCustomEvent<{ key: TPropertyButtonsTypes }>) => void;
        "onCheckClicked"?: (event: IglBookPropertyHeaderCustomEvent<any>) => void;
        "onSourceDropDownChange"?: (event: IglBookPropertyHeaderCustomEvent<string>) => void;
        "onSpiltBookingSelected"?: (event: IglBookPropertyHeaderCustomEvent<{ key: string; data: unknown }>) => void;
        "onSplitBookingDropDownChange"?: (event: IglBookPropertyHeaderCustomEvent<any>) => void;
        "onToast"?: (event: IglBookPropertyHeaderCustomEvent<IToast>) => void;
        "propertyId"?: number;
        "showSplitBookingOption"?: boolean;
        "sourceOptions"?: TSourceOptions[];
        "splitBookingId"?: any;
        "splitBookings"?: any[];
        "wasBlockedUnit"?: boolean;
    }
    interface IglBookingEvent {
        "allBookingEvents"?: { [key: string]: any };
        "bookingEvent"?: { [key: string]: any };
        "countries"?: ICountry[];
        "currency"?: any;
        "is_vacation_rental"?: boolean;
        "language"?: string;
        "onDragOverEventData"?: (event: IglBookingEventCustomEvent<any>) => void;
        "onHideBubbleInfo"?: (event: IglBookingEventCustomEvent<any>) => void;
        "onResetStreachedBooking"?: (event: IglBookingEventCustomEvent<string>) => void;
        "onShowDialog"?: (event: IglBookingEventCustomEvent<CalendarModalEvent>) => void;
        "onShowRoomNightsDialog"?: (event: IglBookingEventCustomEvent<IRoomNightsData>) => void;
        "onToast"?: (event: IglBookingEventCustomEvent<IToast>) => void;
        "onUpdateBookingEvent"?: (event: IglBookingEventCustomEvent<{ [key: string]: any }>) => void;
        "onUpdateEventData"?: (event: IglBookingEventCustomEvent<any>) => void;
    }
    interface IglBookingEventHover {
        "bookingEvent"?: { [key: string]: any };
        "bubbleInfoTop"?: boolean;
        "countries"?: ICountry[];
        "currency"?: any;
        "is_vacation_rental"?: boolean;
        "onBookingCreated"?: (event: IglBookingEventHoverCustomEvent<{ pool?: string; data: any[] }>) => void;
        "onDeleteButton"?: (event: IglBookingEventHoverCustomEvent<string>) => void;
        "onHideBubbleInfo"?: (event: IglBookingEventHoverCustomEvent<any>) => void;
        "onShowBookingPopup"?: (event: IglBookingEventHoverCustomEvent<any>) => void;
        "onShowDialog"?: (event: IglBookingEventHoverCustomEvent<CalendarModalEvent>) => void;
    }
    interface IglBookingForm {
        "bedPreferenceType"?: any;
        "bookedByInfoData"?: { [key: string]: any };
        "bookingData"?: { [key: string]: any };
        "countries"?: ICountry[];
        "currency"?: ICurrency;
        "dateRangeData"?: { [key: string]: any };
        "defaultGuestData"?: IglBookPropertyPayloadEditBooking;
        "isEditOrAddRoomEvent"?: boolean;
        "isLoading"?: string;
        "language"?: string;
        "onButtonClicked"?: (event: IglBookingFormCustomEvent<{
    key: TPropertyButtonsTypes;
    data?: CustomEvent;
  }>) => void;
        "onDataUpdateEvent"?: (event: IglBookingFormCustomEvent<IPageTwoDataUpdateProps>) => void;
        "propertyId"?: number;
        "selectedGuestData"?: any;
        "selectedRooms"?: Map<string, Map<string, any>>;
        "showPaymentDetails"?: boolean;
        "showSplitBookingOption"?: boolean;
    }
    interface IglBookingOverviewPage {
        "adultChildConstraints"?: TAdultChildConstraints1;
        "adultChildCount"?: { adult: number; child: number };
        "bookedByInfoData"?: any;
        "bookingData"?: any;
        "currency"?: any;
        "dateRangeData"?: any;
        "defaultDaterange"?: { from_date: string; to_date: string };
        "eventType"?: string;
        "initialRoomIds"?: any;
        "message"?: string;
        "onRoomsDataUpdate"?: (event: IglBookingOverviewPageCustomEvent<any>) => void;
        "propertyId"?: number;
        "ratePricingMode"?: any;
        "selectedRooms"?: Map<string, Map<string, any>>;
        "showSplitBookingOption"?: boolean;
        "sourceOptions"?: TSourceOptions[];
        "wasBlockedUnit"?: boolean;
    }
    interface IglBulkStopSale {
        "maxDatesLength"?: number;
        "onCloseModal"?: (event: IglBulkStopSaleCustomEvent<null>) => void;
        "onToast"?: (event: IglBulkStopSaleCustomEvent<IToast>) => void;
    }
    interface IglCalBody {
        "calendarData"?: { [key: string]: any };
        "countries"?: ICountry[];
        "currency"?: any;
        "highlightedDate"?: string;
        "isScrollViewDragging"?: boolean;
        "language"?: string;
        "onAddBookingDatasEvent"?: (event: IglCalBodyCustomEvent<any[]>) => void;
        "onScrollPageToRoom"?: (event: IglCalBodyCustomEvent<any>) => void;
        "onShowBookingPopup"?: (event: IglCalBodyCustomEvent<any>) => void;
        "propertyId"?: number;
        "today"?: String;
    }
    interface IglCalFooter {
        "calendarData"?: { [key: string]: any };
        "highlightedDate"?: string;
        "onOptionEvent"?: (event: IglCalFooterCustomEvent<{ [key: string]: any }>) => void;
        "today"?: String;
    }
    interface IglCalHeader {
        "calendarData"?: { [key: string]: any };
        "highlightedDate"?: string;
        "onGotoRoomEvent"?: (event: IglCalHeaderCustomEvent<{
    [key: string]: any;
  }>) => void;
        "onGotoToBeAssignedDate"?: (event: IglCalHeaderCustomEvent<{
    [key: string]: any;
  }>) => void;
        "onOptionEvent"?: (event: IglCalHeaderCustomEvent<{ [key: string]: any }>) => void;
        "propertyid"?: number;
        "to_date"?: string;
        "today"?: String;
        "unassignedDates"?: any;
    }
    interface IglDateRange {
        "dateLabel"?: string;
        "defaultData"?: { [key: string]: any };
        "disabled"?: boolean;
        "maxDate"?: string;
        "minDate"?: string;
        "onDateSelectEvent"?: (event: IglDateRangeCustomEvent<{ [key: string]: any }>) => void;
        "onToast"?: (event: IglDateRangeCustomEvent<IToast>) => void;
        "variant"?: 'booking' | 'default';
        "withDateDifference"?: boolean;
    }
    interface IglLegends {
        "legendData"?: { [key: string]: any };
        "onOptionEvent"?: (event: IglLegendsCustomEvent<{ [key: string]: any }>) => void;
    }
    interface IglPropertyBookedBy {
        "countries"?: ICountry[];
        "defaultData"?: { [key: string]: any };
        "language"?: string;
        "onDataUpdateEvent"?: (event: IglPropertyBookedByCustomEvent<{ [key: string]: any }>) => void;
        "propertyId"?: number;
        "showPaymentDetails"?: boolean;
    }
    interface IglRatePlan {
        "bookingType"?: string;
        "currency": { symbol: string };
        "isBookDisabled"?: boolean;
        "onButtonClicked"?: (event: IglRatePlanCustomEvent<{ [key: string]: any }>) => void;
        "ratePlan"?: RatePlan;
        "ratePricingMode"?: Array<{ CODE_NAME: string; CODE_VALUE_EN: string }>;
        "roomTypeId"?: number;
        "shouldBeDisabled": boolean;
        "visibleInventory": IRatePlanSelection;
    }
    interface IglRoomType {
        "bookingType"?: string;
        "currency"?: any;
        "dateDifference"?: number;
        "initialRoomIds"?: any;
        "isBookDisabled"?: boolean;
        "onDataUpdateEvent"?: (event: IglRoomTypeCustomEvent<{ [key: string]: any }>) => void;
        "ratePricingMode"?: any[];
        "roomInfoId"?: number | null;
        "roomType"?: RoomType;
    }
    interface IglTbaBookingView {
        "calendarData"?: { [key: string]: any };
        "categoriesData"?: { [key: string]: any };
        "categoryId"?: any;
        "categoryIndex"?: any;
        "eventData"?: { [key: string]: any };
        "eventIndex"?: any;
        "onAddToBeAssignedEvent"?: (event: IglTbaBookingViewCustomEvent<any>) => void;
        "onAssignRoomEvent"?: (event: IglTbaBookingViewCustomEvent<{ [key: string]: any }>) => void;
        "onHighlightToBeAssignedBookingEvent"?: (event: IglTbaBookingViewCustomEvent<any>) => void;
        "onOpenCalendarSidebar"?: (event: IglTbaBookingViewCustomEvent<CalendarSidebarState>) => void;
        "onScrollPageToRoom"?: (event: IglTbaBookingViewCustomEvent<any>) => void;
        "selectedDate"?: any;
    }
    interface IglTbaCategoryView {
        "calendarData"?: { [key: string]: any };
        "categoriesData"?: { [key: string]: any };
        "categoryId"?: any;
        "categoryIndex"?: any;
        "eventDatas"?: any;
        "onAssignUnitEvent"?: (event: IglTbaCategoryViewCustomEvent<{ [key: string]: any }>) => void;
        "selectedDate"?: any;
    }
    interface IglToBeAssigned {
        "calendarData"?: { [key: string]: any };
        "from_date"?: string;
        "onAddToBeAssignedEvent"?: (event: IglToBeAssignedCustomEvent<any>) => void;
        "onHighlightToBeAssignedBookingEvent"?: (event: IglToBeAssignedCustomEvent<any>) => void;
        "onOptionEvent"?: (event: IglToBeAssignedCustomEvent<{ [key: string]: any }>) => void;
        "onReduceAvailableUnitEvent"?: (event: IglToBeAssignedCustomEvent<{ [key: string]: any }>) => void;
        "onShowBookingPopup"?: (event: IglToBeAssignedCustomEvent<any>) => void;
        "propertyid"?: number;
        "to_date"?: string;
        "unassignedDatesProp"?: any;
    }
    interface IglooCalendar {
        "baseUrl"?: string;
        "currencyName"?: string;
        "from_date"?: string;
        "language"?: string;
        "loadingMessage"?: string;
        "onCalculateUnassignedDates"?: (event: IglooCalendarCustomEvent<any>) => void;
        "onDragOverHighlightElement"?: (event: IglooCalendarCustomEvent<any>) => void;
        "onMoveBookingTo"?: (event: IglooCalendarCustomEvent<any>) => void;
        "onOpenCalendarSidebar"?: (event: IglooCalendarCustomEvent<CalendarSidebarState>) => void;
        "onReduceAvailableUnitEvent"?: (event: IglooCalendarCustomEvent<{ fromDate: string; toDate: string }>) => void;
        "onRevertBooking"?: (event: IglooCalendarCustomEvent<any>) => void;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
        "to_date"?: string;
    }
    interface IrAutocomplete {
        "danger_border"?: boolean;
        "disabled"?: boolean;
        "duration"?: number;
        "from_date"?: string;
        "inputId"?: string;
        "isSplitBooking"?: boolean;
        "name"?: string;
        "onComboboxValue"?: (event: IrAutocompleteCustomEvent<{ key: string; data: unknown }>) => void;
        "onInputCleared"?: (event: IrAutocompleteCustomEvent<null>) => void;
        "onToast"?: (event: IrAutocompleteCustomEvent<IToast1>) => void;
        "placeholder"?: string;
        "propertyId"?: number;
        "required"?: boolean;
        "testId"?: string;
        "to_date"?: string;
        "type"?: 'email' | 'text' | 'password' | 'number' | 'search';
        "value"?: string;
    }
    interface IrBooking {
        "bookingNumber"?: string;
        "p"?: string;
        "propertyid"?: number;
    }
    interface IrBookingDetails {
        "bookingNumber"?: string;
        "hasCheckIn"?: boolean;
        "hasCheckOut"?: boolean;
        "hasCloseButton"?: boolean;
        "hasDelete"?: boolean;
        "hasMenu"?: boolean;
        "hasPrint"?: boolean;
        "hasReceipt"?: boolean;
        "hasRoomAdd"?: boolean;
        "hasRoomDelete"?: boolean;
        "hasRoomEdit"?: boolean;
        "is_from_front_desk"?: boolean;
        "language"?: string;
        "onBookingChanged"?: (event: IrBookingDetailsCustomEvent<Booking>) => void;
        "onCloseSidebar"?: (event: IrBookingDetailsCustomEvent<null>) => void;
        "onToast"?: (event: IrBookingDetailsCustomEvent<IToast>) => void;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
    }
    interface IrBookingExtraNote {
        "booking"?: Booking;
        "onCloseModal"?: (event: IrBookingExtraNoteCustomEvent<null>) => void;
        "onResetBookingEvt"?: (event: IrBookingExtraNoteCustomEvent<Booking | null>) => void;
    }
    interface IrBookingHeader {
        "booking"?: Booking;
        "hasCloseButton"?: boolean;
        "hasDelete"?: boolean;
        "hasEmail"?: boolean;
        "hasMenu"?: boolean;
        "hasPrint"?: boolean;
        "hasReceipt"?: boolean;
        "onCloseSidebar"?: (event: IrBookingHeaderCustomEvent<null>) => void;
        "onOpenSidebar"?: (event: IrBookingHeaderCustomEvent<OpenSidebarEvent<any>>) => void;
        "onResetBookingEvt"?: (event: IrBookingHeaderCustomEvent<null>) => void;
        "onToast"?: (event: IrBookingHeaderCustomEvent<IToast>) => void;
    }
    interface IrBookingListing {
        "baseUrl"?: string;
        "language"?: string;
        "p"?: string;
        "propertyid"?: number;
        "rowCount"?: number;
        "ticket"?: string;
    }
    interface IrBookingPrinting {
        "bookingNumber"?: string;
        "countries"?: any;
        "language"?: string;
        "mode"?: 'invoice' | 'default';
        "propertyid"?: number;
        "token"?: string;
    }
    interface IrButton {
        /**
          * Custom inline styles for the button element.
         */
        "btnStyle"?: { [key: string]: string };
        /**
          * Whether the button should expand to the full width of its container.
         */
        "btn_block"?: boolean;
        /**
          * The color theme of the button.
         */
        "btn_color"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | 'outline' | 'link';
        /**
          * Disables the button when set to true.
         */
        "btn_disabled"?: boolean;
        /**
          * A unique identifier for the button instance.
         */
        "btn_id"?: string;
        /**
          * Additional custom class names for the button.
         */
        "btn_styles"?: string;
        /**
          * The button type attribute (`button`, `submit`, or `reset`).
         */
        "btn_type"?: string;
        /**
          * Position of the icon relative to the button text.
         */
        "iconPosition"?: 'left' | 'right';
        /**
          * The name of the icon to display.
         */
        "icon_name"?: TIcons;
        /**
          * Custom style object for the icon.
         */
        "icon_style"?: any;
        /**
          * Displays a loading indicator when true and disables the button.
         */
        "isLoading"?: boolean;
        /**
          * Custom inline styles for the label/text inside the button.
         */
        "labelStyle"?: { [key: string]: string };
        /**
          * The name of the button, used for identification purposes.
         */
        "name"?: string;
        /**
          * Emits a custom click event when the button is clicked.
         */
        "onClickHandler"?: (event: IrButtonCustomEvent<any>) => void;
        /**
          * If true, renders the text property as raw HTML inside the button.
         */
        "renderContentAsHtml"?: boolean;
        /**
          * The size of the button.
         */
        "size"?: 'sm' | 'md' | 'lg';
        /**
          * The text content displayed inside the button.
         */
        "text"?: string;
        /**
          * The size of the text inside the button.
         */
        "textSize"?: 'sm' | 'md' | 'lg';
        /**
          * Visual variant of the button: either standard (`default`) or icon-only (`icon`).
         */
        "variant"?: 'default' | 'icon';
        /**
          * If true, applies a visible background when hovered.
         */
        "visibleBackgroundOnHover"?: boolean;
    }
    interface IrChannel {
        "baseurl"?: string;
        "language"?: string;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
    }
    interface IrChannelEditor {
        "channel_status"?: 'create' | 'edit' | null;
        "onCloseSideBar"?: (event: IrChannelEditorCustomEvent<null>) => void;
        "onSaveChannelFinished"?: (event: IrChannelEditorCustomEvent<null>) => void;
        "onToast"?: (event: IrChannelEditorCustomEvent<IToast>) => void;
        "ticket"?: string;
    }
    interface IrChannelGeneral {
        "channel_status"?: 'create' | 'edit' | null;
        "onConnectionStatus"?: (event: IrChannelGeneralCustomEvent<boolean>) => void;
    }
    interface IrChannelHeader {
        "headerTitles"?: { id: string; name: string; disabled: boolean }[];
        "onTabChanged"?: (event: IrChannelHeaderCustomEvent<string>) => void;
    }
    interface IrChannelMapping {
    }
    interface IrCheckbox {
        /**
          * The unique ID of the checkbox element.
         */
        "checkboxId"?: string;
        /**
          * Whether the checkbox is checked.
         */
        "checked"?: boolean;
        /**
          * Disables the checkbox when true.
         */
        "disabled"?: boolean;
        /**
          * Whether the checkbox is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * The label text associated with the checkbox.
         */
        "label"?: string;
        /**
          * CSS class applied to the label element.
         */
        "labelClass"?: string;
        /**
          * The name attribute of the checkbox, used for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the checkbox's checked state changes.
         */
        "onCheckChange"?: (event: IrCheckboxCustomEvent<boolean>) => void;
    }
    interface IrCheckboxes {
        "checkboxes"?: checkboxes[];
        "onCheckboxesChange"?: (event: IrCheckboxesCustomEvent<checkboxes[]>) => void;
    }
    interface IrCombobox {
        /**
          * Autofocuses the input field when true.
         */
        "autoFocus"?: boolean;
        /**
          * The list of items displayed in the combobox.
         */
        "data"?: ComboboxItem[];
        /**
          * Disables the combobox input when set to true.
         */
        "disabled"?: boolean;
        /**
          * Debounce duration in milliseconds for search input.
         */
        "duration"?: number;
        /**
          * Unique identifier for the input element.
         */
        "input_id"?: string;
        /**
          * Emitted when a selection is made from the combobox.
         */
        "onComboboxValueChange"?: (event: IrComboboxCustomEvent<{ key: string; data: unknown }>) => void;
        /**
          * Emitted when the input is cleared by the user.
         */
        "onInputCleared"?: (event: IrComboboxCustomEvent<null>) => void;
        /**
          * Emits a toast notification.
         */
        "onToast"?: (event: IrComboboxCustomEvent<IToast>) => void;
        /**
          * Placeholder text for the input field.
         */
        "placeholder"?: string;
        /**
          * The current value of the input field.
         */
        "value"?: string;
    }
    interface IrCommon {
        "extraResources"?: string;
    }
    interface IrCountryPicker {
        /**
          * Whether to automatically validate the input.
         */
        "autoValidate"?: boolean;
        /**
          * List of countries to display in the dropdown.
         */
        "countries"?: ICountry[];
        /**
          * Currently selected country.
         */
        "country"?: ICountry;
        /**
          * Whether to show an error state on the input.
         */
        "error"?: boolean;
        /**
          * The label to display for the input.
         */
        "label"?: string;
        /**
          * Event emitted when a country is selected.
         */
        "onCountryChange"?: (event: IrCountryPickerCustomEvent<ICountry>) => void;
        /**
          * The property-associated country, shown separately if relevant.
         */
        "propertyCountry"?: ICountry;
        /**
          * Test ID for automated testing.
         */
        "testId"?: string;
    }
    interface IrDatePicker {
        /**
          * Closes the picker automatically after a date is selected.
         */
        "autoClose"?: boolean;
        /**
          * Pass a container element if you need the date picker to be appended to a specific element for styling or positioning (particularly for arrow rendering). If not provided, it defaults to `this.el`.
         */
        "container"?: HTMLElement;
        /**
          * Controls how the date picker is triggered. - **`true`**: The picker can be triggered by custom UI elements (provided via a `<slot name="trigger">`). - **`false`**: A default button input is used to open the picker.  Defaults to `true`.
         */
        "customPicker"?: boolean;
        /**
          * The initially selected date; can be a `Date` object or a string recognized by `AirDatepicker`.
         */
        "date"?: string | Date | null;
        /**
          * Format for the date as it appears in the input field. Follows the `AirDatepicker` format rules.
         */
        "dateFormat"?: string;
        /**
          * Disables the input and prevents interaction.
         */
        "disabled"?: boolean;
        /**
          * If `true`, the component will emit a `dateChanged` event when the selected date becomes empty (null). Otherwise, empty-date changes will be ignored (no event emitted).  Defaults to `false`.
         */
        "emitEmptyDate"?: boolean;
        /**
          * If `true`, the date picker instance is destroyed and rebuilt each time the `date` prop changes. This can be useful if you need the picker to fully re-initialize in response to dynamic changes, but note that it may affect performance if triggered frequently. Defaults to `false`.
         */
        "forceDestroyOnUpdate"?: boolean;
        /**
          * Determines whether the date picker is rendered inline or in a pop-up. If `true`, the picker is always visible inline.
         */
        "inline"?: boolean;
        /**
          * The latest date that can be selected.
         */
        "maxDate"?: string | Date;
        /**
          * The earliest date that can be selected.
         */
        "minDate"?: string | Date;
        /**
          * Enables multiple dates. If `true`, multiple selection is allowed. If you pass a number (e.g. 3), that is the maximum number of selectable dates.
         */
        "multipleDates"?: boolean | number;
        "onDateChanged"?: (event: IrDatePickerCustomEvent<{
    start: moment.Moment;
    end: moment.Moment;
  }>) => void;
        "onDatePickerBlur"?: (event: IrDatePickerCustomEvent<void>) => void;
        "onDatePickerFocus"?: (event: IrDatePickerCustomEvent<void>) => void;
        /**
          * Whether the picker should allow range selection (start and end date).
         */
        "range"?: boolean;
        /**
          * Allows selecting days from previous/next month shown in the current view.
         */
        "selectOtherMonths"?: boolean;
        /**
          * Shows days from previous/next month in the current month's calendar.
         */
        "showOtherMonths"?: boolean;
        /**
          * Enables the timepicker functionality (select hours and minutes).
         */
        "timepicker"?: boolean;
        /**
          * Styles for the trigger container
         */
        "triggerContainerStyle"?: string;
    }
    interface IrDateRange {
        /**
          * Text shown on the Apply button.
         */
        "applyLabel"?: string;
        /**
          * Whether to apply the selected range automatically without clicking 'Apply'.
         */
        "autoApply"?: boolean;
        /**
          * Text shown on the Cancel button.
         */
        "cancelLabel"?: string;
        /**
          * Label used for the custom date range option.
         */
        "customRangeLabel"?: string;
        /**
          * Single date selection value (used in single date picker mode).
         */
        "date"?: Date;
        /**
          * Abbreviated names of the days of the week.
         */
        "daysOfWeek"?: string[];
        /**
          * Disables the date range input when true.
         */
        "disabled"?: boolean;
        /**
          * First day of the week (0 = Sunday, 1 = Monday, ...).
         */
        "firstDay"?: number;
        /**
          * Date format used in the input and picker.
         */
        "format"?: string;
        /**
          * Start date for the date range.
         */
        "fromDate"?: Date;
        /**
          * Label for the "From" date input.
         */
        "fromLabel"?: string;
        /**
          * Maximum selectable date.
         */
        "maxDate"?: string | Date;
        /**
          * Maximum range span (e.g., `{ days: 240 }`).
         */
        "maxSpan"?: moment.DurationInputArg1;
        /**
          * Minimum selectable date.
         */
        "minDate"?: string | Date;
        /**
          * Month names shown in the calendar header.
         */
        "monthNames"?: string[];
        /**
          * Emits when a new date range is selected.  Example: ```tsx <ir-date-range onDateChanged={(e) => console.log(e.detail)} /> ```
         */
        "onDateChanged"?: (event: IrDateRangeCustomEvent<{
    start: moment.Moment;
    end: moment.Moment;
  }>) => void;
        /**
          * Defines which side the calendar opens to. Options: `'left'`, `'right'`, `'center'`.
         */
        "opens"?: 'left' | 'right' | 'center';
        /**
          * Separator string used between start and end dates.
         */
        "separator"?: string;
        /**
          * Enables single date selection mode.
         */
        "singleDatePicker"?: boolean;
        /**
          * End date for the date range.
         */
        "toDate"?: Date;
        /**
          * Label for the "To" date input.
         */
        "toLabel"?: string;
        /**
          * Label for the week column in the calendar.
         */
        "weekLabel"?: string;
    }
    interface IrDateView {
        "dateOption"?: string;
        "from_date"?: string | Date | moment.Moment;
        "showDateDifference"?: boolean;
        "to_date"?: string | Date | moment.Moment;
    }
    interface IrDeleteModal {
        "onModalClosed"?: (event: IrDeleteModalCustomEvent<null>) => void;
        "onResetData"?: (event: IrDeleteModalCustomEvent<string>) => void;
        "user"?: IHouseKeepers;
    }
    interface IrDialog {
        /**
          * Emits the open/close state of the modal.  Example: ```tsx <ir-dialog onOpenChange={(e) => console.log(e.detail)} /> ```
         */
        "onOpenChange"?: (event: IrDialogCustomEvent<boolean>) => void;
        /**
          * Controls whether the dialog should be opened. Can be updated externally and watched internally.
         */
        "open"?: boolean;
    }
    interface IrDrawer {
        /**
          * The title of the drawer
         */
        "drawerTitle"?: string;
        /**
          * Emitted when the drawer visibility changes.
         */
        "onDrawerChange"?: (event: IrDrawerCustomEvent<boolean>) => void;
        /**
          * Emitted when the drawer is requested to be closed via keyboard
         */
        "onDrawerCloseRequested"?: (event: IrDrawerCustomEvent<void>) => void;
        /**
          * Is the drawer open?
         */
        "open"?: boolean;
        /**
          * The placement of the drawer
         */
        "placement"?: 'left' | 'right';
    }
    interface IrDropdown {
        "data"?: {
    name: string;
    icon: string;
    children: {
      name: string;
      icon: string;
    }[];
  };
        "object"?: any;
        "onDropdownItemCLicked"?: (event: IrDropdownCustomEvent<{ name: string; object: any }>) => void;
    }
    interface IrEventsLog {
        "bookingNumber"?: string;
    }
    interface IrExtraService {
        "bookingNumber"?: string;
        "currencySymbol"?: string;
        "onEditExtraService"?: (event: IrExtraServiceCustomEvent<ExtraService>) => void;
        "onResetBookingEvt"?: (event: IrExtraServiceCustomEvent<null>) => void;
        "service"?: ExtraService;
    }
    interface IrExtraServiceConfig {
        "booking"?: Pick<Booking, 'from_date' | 'to_date' | 'currency' | 'booking_nbr'>;
        "onCloseModal"?: (event: IrExtraServiceConfigCustomEvent<null>) => void;
        "onResetBookingEvt"?: (event: IrExtraServiceConfigCustomEvent<null>) => void;
        "service"?: ExtraService;
    }
    interface IrExtraServices {
        "booking"?: Pick<Booking, 'currency' | 'extra_services' | 'booking_nbr'>;
    }
    interface IrGuestInfo {
        "booking_nbr"?: string;
        "email"?: string;
        "headerShown"?: boolean;
        "isInSideBar"?: boolean;
        "language"?: string;
        "onCloseSideBar"?: (event: IrGuestInfoCustomEvent<null>) => void;
        "onResetBookingEvt"?: (event: IrGuestInfoCustomEvent<null>) => void;
        "ticket"?: string;
    }
    interface IrHkArchive {
        "language"?: string;
        "propertyId"?: string | number;
        "ticket"?: string;
    }
    interface IrHkTasks {
        "baseUrl"?: string;
        "language"?: string;
        "onClearSelectedHkTasks"?: (event: IrHkTasksCustomEvent<void>) => void;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
    }
    interface IrHkTeam {
    }
    interface IrHkUnassignedUnits {
        "onCloseSideBar"?: (event: IrHkUnassignedUnitsCustomEvent<null>) => void;
        "onResetData"?: (event: IrHkUnassignedUnitsCustomEvent<null>) => void;
        "user"?: IHouseKeepers | null;
    }
    interface IrHkUser {
        "isEdit"?: boolean;
        "onCloseSideBar"?: (event: IrHkUserCustomEvent<null>) => void;
        "onResetData"?: (event: IrHkUserCustomEvent<null>) => void;
        "user"?: THKUser | null;
    }
    interface IrHousekeeping {
        "baseUrl"?: string;
        "language"?: string;
        "onToast"?: (event: IrHousekeepingCustomEvent<IToast>) => void;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
    }
    interface IrIcon {
        "icon"?: string;
        "onIconClickHandler"?: (event: IrIconCustomEvent<any>) => void;
        "type"?: 'button' | 'submit' | 'reset';
    }
    interface IrIcons {
        /**
          * Sets the `color` attribute on the `<svg>` element. Accepts any valid CSS color string.
         */
        "color"?: string;
        /**
          * The name of the icon to render. Must match a key from the imported `icons` map.  Example: ```tsx <ir-icons name="check" /> ```
         */
        "name"?: TIcons;
        /**
          * Additional CSS class applied to the `<svg>` element. Can be used for sizing, positioning, etc.
         */
        "svgClassName"?: string;
    }
    interface IrInputText {
        /**
          * A Zod parse type for validating the input
         */
        "asyncParse"?: boolean;
        /**
          * Autocomplete behavior for the input (e.g., 'on', 'off', 'email', etc.)
         */
        "autoComplete"?: string;
        /**
          * Whether the input should auto-validate
         */
        "autoValidate"?: boolean;
        /**
          * To clear all the Input base styling
         */
        "clearBaseStyles"?: boolean;
        /**
          * Whether the input is disabled
         */
        "disabled"?: boolean;
        /**
          * Whether the input has an error
         */
        "error"?: boolean;
        /**
          * To clear all the Input base styling
         */
        "errorMessage"?: string;
        /**
          * Forcing css style to the input
         */
        "inputForcedStyle"?: { [key: string]: string };
        /**
          * Whether to apply default input styling
         */
        "inputStyle"?: boolean;
        /**
          * Additional inline styles for the input
         */
        "inputStyles"?: string;
        /**
          * Label text for the input
         */
        "label"?: string;
        /**
          * Background color of the label
         */
        "labelBackground"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | null;
        /**
          * Border color/style of the label
         */
        "labelBorder"?: 'theme' | 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | 'none';
        /**
          * Text color of the label
         */
        "labelColor"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        /**
          * Position of the label: left, right, or center
         */
        "labelPosition"?: 'left' | 'right' | 'center';
        /**
          * Label width as a fraction of 12 columns (1-11)
         */
        "labelWidth"?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
        /**
          * Mask for the input field (optional)
         */
        "mask"?: FactoryArg;
        /**
          * Input max character length
         */
        "maxLength"?: number;
        /**
          * Name attribute for the input field
         */
        "name"?: string;
        "onInputBlur"?: (event: IrInputTextCustomEvent<FocusEvent>) => void;
        "onInputFocus"?: (event: IrInputTextCustomEvent<FocusEvent>) => void;
        "onTextChange"?: (event: IrInputTextCustomEvent<any>) => void;
        /**
          * Placeholder text for the input
         */
        "placeholder"?: string;
        /**
          * Whether the input field is read-only
         */
        "readonly"?: boolean;
        /**
          * Whether the input field is required
         */
        "required"?: boolean;
        /**
          * Whether the form has been submitted
         */
        "submitted"?: boolean;
        /**
          * Input id for testing purposes
         */
        "testId"?: string;
        /**
          * Text size inside the input field
         */
        "textSize"?: 'sm' | 'md' | 'lg';
        /**
          * Input type (e.g., text, password, email)
         */
        "type"?: | 'text'
    | 'password'
    | 'email'
    | 'number'
    | 'tel'
    | 'url'
    | 'search'
    | 'date'
    | 'datetime-local'
    | 'month'
    | 'week'
    | 'time'
    | 'color'
    | 'file'
    | 'hidden'
    | 'checkbox'
    | 'radio'
    | 'range'
    | 'button'
    | 'reset'
    | 'submit'
    | 'image';
        /**
          * Value of the input field
         */
        "value"?: string;
        /**
          * Variant of the input: default or icon
         */
        "variant"?: 'default' | 'icon';
        /**
          * Key to wrap the value (e.g., 'price' or 'cost')
         */
        "wrapKey"?: string;
        /**
          * A Zod schema for validating the input
         */
        "zod"?: ZodType<any, any>;
    }
    interface IrInteractiveTitle {
        /**
          * The number of characters to display before cropping the title with ellipsis.
         */
        "cropSize"?: number;
        /**
          * Whether to show the housekeeping (HK) status dot.
         */
        "hkStatus"?: boolean;
        /**
          * CSS offset for the left position of the popover. Used as a CSS variable `--ir-popover-left`.
         */
        "irPopoverLeft"?: string;
        /**
          * The full title string that may be cropped in the UI.
         */
        "popoverTitle"?: string;
    }
    interface IrInterceptor {
        /**
          * List of endpoint paths that should trigger loader logic and OTP handling.
         */
        "handledEndpoints"?: string[];
        /**
          * Emits a toast notification (`type`, `title`, `description`, `position`).
         */
        "onToast"?: (event: IrInterceptorCustomEvent<IToast>) => void;
        /**
          * List of endpoints for which to suppress toast messages.
         */
        "suppressToastEndpoints"?: string[];
    }
    interface IrLabel {
        /**
          * inline styles for the component container
         */
        "containerStyle"?: {
    [key: string]: string;
  };
        /**
          * The main text or HTML content to display
         */
        "content"?: string;
        "display"?: 'inline' | 'flex';
        /**
          * If true, label will ignore checking for an empty content
         */
        "ignoreEmptyContent"?: boolean;
        /**
          * Object representing the image used within the label
         */
        "image"?: { src: string; alt: string; style?: string } | null;
        /**
          * Additional CSS classes or style for the image
         */
        "imageStyle"?: string;
        /**
          * Renders a country-type image style (vs. a 'logo')
         */
        "isCountryImage"?: boolean;
        /**
          * The text to display as the label's title
         */
        "labelText"?: string;
        /**
          * Placeholder text to display if content is empty
         */
        "placeholder"?: string;
        /**
          * If true, will render `content` as HTML
         */
        "renderContentAsHtml"?: boolean;
    }
    interface IrListingHeader {
        "language"?: string;
        "onPreventPageLoad"?: (event: IrListingHeaderCustomEvent<string>) => void;
        "p"?: string;
        "propertyId"?: number;
    }
    interface IrListingModal {
        "editBooking"?: { booking: Booking; cause: 'edit' | 'payment' | 'delete' | 'guest' };
        "modalTitle"?: string;
        "onModalClosed"?: (event: IrListingModalCustomEvent<null>) => void;
        "onResetData"?: (event: IrListingModalCustomEvent<string>) => void;
    }
    interface IrLoadingScreen {
        "message"?: string;
    }
    interface IrLogin {
        "onAuthFinish"?: (event: IrLoginCustomEvent<{
    token: string;
    code: 'succsess' | 'error';
  }>) => void;
    }
    interface IrModal {
        /**
          * If true, the modal automatically closes after confirm/cancel actions.
         */
        "autoClose"?: boolean;
        /**
          * Horizontal alignment of the footer buttons.
         */
        "btnPosition"?: 'left' | 'right' | 'center';
        /**
          * Icon name to render next to the title (if `iconAvailable` is true).
         */
        "icon"?: string;
        /**
          * Whether an icon should be displayed next to the title.
         */
        "iconAvailable"?: boolean;
        /**
          * Whether the modal is in a loading state, disabling interaction.
         */
        "isLoading"?: boolean;
        /**
          * Payload object to pass along with confirm/cancel events.
         */
        "item"?: any;
        /**
          * Whether the left (cancel/close) button is visible.
         */
        "leftBtnActive"?: boolean;
        /**
          * Color theme of the left button.
         */
        "leftBtnColor"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        /**
          * Text displayed on the left (cancel/close) button.
         */
        "leftBtnText"?: string;
        /**
          * The main content text shown in the modal body.
         */
        "modalBody"?: string;
        /**
          * The title text displayed in the modal header.
         */
        "modalTitle"?: string;
        /**
          * Fired when the cancel (left) button or backdrop is clicked.
         */
        "onCancelModal"?: (event: IrModalCustomEvent<any>) => void;
        /**
          * Fired when the confirm (right) button is clicked. Emits the current `item` value.
         */
        "onConfirmModal"?: (event: IrModalCustomEvent<any>) => void;
        /**
          * Whether the right (confirm) button is visible.
         */
        "rightBtnActive"?: boolean;
        /**
          * Color theme of the right button.
         */
        "rightBtnColor"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        /**
          * Text displayed on the right (confirm) button.
         */
        "rightBtnText"?: string;
        /**
          * Controls whether the modal title is rendered.
         */
        "showTitle"?: boolean;
    }
    interface IrOptionDetails {
        "onCloseModal"?: (event: IrOptionDetailsCustomEvent<PaymentOption | null>) => void;
        "onToast"?: (event: IrOptionDetailsCustomEvent<IToast>) => void;
        "propertyId"?: string;
    }
    interface IrOtaService {
        "service"?: OtaService;
    }
    interface IrOtaServices {
        "services"?: OtaService[];
    }
    interface IrOtp {
        /**
          * Auto focus on the first input when component loads
         */
        "autoFocus"?: boolean;
        /**
          * The default OTP code
         */
        "defaultValue"?: string;
        /**
          * Whether the input is disabled
         */
        "disabled"?: boolean;
        /**
          * The length of the OTP code
         */
        "length"?: number;
        /**
          * Allow only numbers (0-9) as input
         */
        "numbersOnly"?: boolean;
        /**
          * Event emitted when the OTP value changes
         */
        "onOtpChange"?: (event: IrOtpCustomEvent<string>) => void;
        /**
          * Event emitted when the OTP is complete
         */
        "onOtpComplete"?: (event: IrOtpCustomEvent<string>) => void;
        /**
          * Placeholder character to display
         */
        "placeholder"?: string;
        /**
          * Whether to mask the input (show dots instead of text)
         */
        "secure"?: boolean;
        /**
          * Input type - can be 'text', 'password', 'number', or 'tel'
         */
        "type"?: 'text' | 'password' | 'number' | 'tel';
    }
    interface IrOtpModal {
        /**
          * URL or endpoint used to validate the OTP
         */
        "baseOTPUrl"?: string;
        /**
          * User's email address to display in the modal and send the OTP to
         */
        "email"?: string;
        "language"?: string;
        /**
          * Emits the final OTP (or empty on cancel)
         */
        "onOtpFinished"?: (event: IrOtpModalCustomEvent<{
    otp: string;
    type: 'success' | 'cancelled';
  }>) => void;
        /**
          * Number of digits the OTP should have
         */
        "otpLength"?: number;
        /**
          * URL or endpoint used to validate the OTP
         */
        "requestUrl"?: string;
        /**
          * Number of seconds to wait before allowing OTP resend
         */
        "resendTimer"?: number;
        /**
          * Whether the resend option should be visible
         */
        "showResend"?: boolean;
        /**
          * ticket for verifying and resending the verification code
         */
        "ticket"?: string;
    }
    interface IrPasswordValidator {
        "onPasswordValidationChange"?: (event: IrPasswordValidatorCustomEvent<boolean>) => void;
        /**
          * The password string to validate
         */
        "password"?: string;
    }
    interface IrPaymentActions {
        "booking"?: Booking;
        "onGeneratePayment"?: (event: IrPaymentActionsCustomEvent<IPaymentAction>) => void;
        "paymentAction"?: IPaymentAction[];
    }
    interface IrPaymentDetails {
        "bookingDetails"?: Booking;
        "onResetBookingEvt"?: (event: IrPaymentDetailsCustomEvent<null>) => void;
        "onResetExposedCancelationDueAmount"?: (event: IrPaymentDetailsCustomEvent<null>) => void;
        "onToast"?: (event: IrPaymentDetailsCustomEvent<IToast>) => void;
        "paymentActions"?: IPaymentAction[];
    }
    interface IrPaymentOption {
        "defaultStyles"?: boolean;
        "hideLogs"?: boolean;
        "language"?: string;
        "onToast"?: (event: IrPaymentOptionCustomEvent<IToast>) => void;
        "p"?: string;
        "propertyid"?: string;
        "ticket"?: string;
    }
    interface IrPhoneInput {
        /**
          * Country list, used to populate prefix and dropdown. If not provided, fetched from the booking service.
         */
        "countries"?: ICountry[];
        /**
          * Default country ID used if no phone prefix is set.
         */
        "default_country"?: number;
        /**
          * Disables the phone input when true.
         */
        "disabled"?: boolean;
        /**
          * If true, styles the input to indicate an error state.
         */
        "error"?: boolean;
        /**
          * Label displayed next to the phone input.
         */
        "label"?: string;
        /**
          * Two-letter language code used for country fetching.
         */
        "language"?: string;
        /**
          * Emits when the user changes the phone number. Emits `{ phone_prefix, mobile }` object.  Example: ```tsx <ir-phone-input onTextChange={(e) => console.log(e.detail)} /> ```
         */
        "onTextChange"?: (event: IrPhoneInputCustomEvent<{ phone_prefix: string; mobile: string }>) => void;
        /**
          * If provided, sets the phone prefix and updates selected country.
         */
        "phone_prefix"?: string | null;
        /**
          * Placeholder text for the input.
         */
        "placeholder"?: string;
        /**
          * Identifier for test automation.
         */
        "testId"?: string;
        /**
          * Auth token used by the booking service (if needed).
         */
        "token"?: string;
        /**
          * Initial phone number value.
         */
        "value"?: string;
    }
    interface IrPickup {
        "bookingDates"?: { from: string; to: string };
        "bookingNumber"?: string;
        "defaultPickupData"?: IBookingPickupInfo | null;
        "numberOfPersons"?: number;
        "onCloseModal"?: (event: IrPickupCustomEvent<null>) => void;
        "onResetBookingEvt"?: (event: IrPickupCustomEvent<null>) => void;
    }
    interface IrPickupView {
        "booking"?: Booking;
    }
    interface IrPmsLogs {
        "bookingNumber"?: string;
    }
    interface IrPopover {
        /**
          * Content to display inside the popover. Can be plain text or HTML depending on `renderContentAsHtml`.
         */
        "content"?: string;
        /**
          * Horizontal offset (left) of the popover from its trigger. Used in inline style as `--ir-popover-left`.
         */
        "irPopoverLeft"?: string;
        /**
          * Position of the popover relative to the trigger. Options: `'top'`, `'bottom'`, `'left'`, `'right'`, `'auto'`.
         */
        "placement"?: 'top' | 'bottom' | 'left' | 'right' | 'auto';
        /**
          * Whether to treat `content` as raw HTML. When true, `content` will be injected with `html: true` in jQuery popover.
         */
        "renderContentAsHtml"?: boolean;
        /**
          * Event that triggers the popover. Options: `'focus'`, `'click'`, `'hover'`.
         */
        "trigger"?: 'focus' | 'click' | 'hover';
    }
    interface IrPriceInput {
        /**
          * The AutoValidate for the input, optional
         */
        "autoValidate"?: boolean;
        /**
          * The Currency for the input, optional
         */
        "currency"?: string;
        /**
          * The disabled for the input, optional
         */
        "disabled"?: boolean;
        /**
          * Extra classnames for the input, optional
         */
        "inputStyle"?: string;
        /**
          * The label for the input, optional
         */
        "label"?: string;
        /**
          * Extra classnames for the label, optional
         */
        "labelStyle"?: string;
        /**
          * Maximum value for the price
         */
        "maxValue"?: number;
        /**
          * Minimum value for the price
         */
        "minValue"?: number;
        /**
          * Emits the current value on blur
         */
        "onInputBlur"?: (event: IrPriceInputCustomEvent<string>) => void;
        /**
          * Emits the current value on focus
         */
        "onInputFocus"?: (event: IrPriceInputCustomEvent<void>) => void;
        /**
          * Emits the current value on change
         */
        "onTextChange"?: (event: IrPriceInputCustomEvent<string>) => void;
        /**
          * Placeholder text for the input
         */
        "placeholder"?: string;
        /**
          * The readonly for the input, optional
         */
        "readOnly"?: boolean;
        /**
          * Whether the input is required
         */
        "required"?: boolean;
        /**
          * Unique id for testing
         */
        "testId"?: string;
        /**
          * Initial value for the input
         */
        "value"?: string;
        /**
          * Indicates the key to wrap the value (e.g., 'price' or 'cost')
         */
        "wrapKey"?: string;
        /**
          * A Zod schema for validating the input Example: z.coerce.number()
         */
        "zod"?: ZodType<any, any>;
    }
    interface IrRadio {
        /**
          * Whether the checkbox is checked.
         */
        "checked"?: boolean;
        /**
          * Disables the checkbox when true.
         */
        "disabled"?: boolean;
        /**
          * Whether the checkbox is in an indeterminate state.
         */
        "indeterminate"?: boolean;
        /**
          * The label text associated with the checkbox.
         */
        "label"?: string;
        /**
          * CSS class applied to the label element.
         */
        "labelClass"?: string;
        /**
          * The name attribute of the checkbox, used for form submission.
         */
        "name"?: string;
        /**
          * Emitted when the checkbox's checked state changes.
         */
        "onCheckChange"?: (event: IrRadioCustomEvent<boolean>) => void;
        /**
          * The unique ID of the checkbox element.
         */
        "radioBoxId"?: string;
    }
    interface IrRangePicker {
        /**
          * Whether to all the emitted dates to be null.
         */
        "allowNullDates"?: boolean;
        /**
          * The start date of the range.
         */
        "fromDate"?: Moment;
        /**
          * The latest date that can be selected.
         */
        "maxDate"?: string | Date;
        /**
          * The earliest date that can be selected.
         */
        "minDate"?: string | Date;
        "onDateRangeChanged"?: (event: IrRangePickerCustomEvent<{ fromDate: Moment; toDate: Moment }>) => void;
        /**
          * The end date of the range.
         */
        "toDate"?: Moment;
        /**
          * Whether to show the overlay before the date is selected.
         */
        "withOverlay"?: boolean;
    }
    interface IrReservationInformation {
        "booking"?: Booking;
        "countries"?: ICountry[];
        "onOpenSidebar"?: (event: IrReservationInformationCustomEvent<OpenSidebarEvent<any>>) => void;
    }
    interface IrResetPassword {
        "language"?: string;
        "old_pwd"?: string;
        "onCloseSideBar"?: (event: IrResetPasswordCustomEvent<null>) => void;
        "skip2Fa"?: boolean;
        "ticket"?: string;
        "username"?: string;
    }
    interface IrRoom {
        "bedPreferences"?: IEntries[];
        "booking"?: Booking;
        "bookingIndex"?: number;
        "currency"?: string;
        "hasCheckIn"?: boolean;
        "hasCheckOut"?: boolean;
        "hasRoomAdd"?: boolean;
        "hasRoomDelete"?: boolean;
        "hasRoomEdit"?: boolean;
        "isEditable"?: boolean;
        "language"?: string;
        "legendData"?: any;
        "mealCodeName"?: string;
        "myRoomTypeFoodCat"?: string;
        "onDeleteFinished"?: (event: IrRoomCustomEvent<string>) => void;
        "onEditInitiated"?: (event: IrRoomCustomEvent<TIglBookPropertyPayload>) => void;
        "onPressCheckIn"?: (event: IrRoomCustomEvent<any>) => void;
        "onPressCheckOut"?: (event: IrRoomCustomEvent<any>) => void;
        "room"?: Room;
        "roomsInfo"?: any;
    }
    interface IrRoomGuests {
        /**
          * A unique booking number associated with the room. This is used for backend operations like saving guest information or checking in the room.
         */
        "bookingNumber"?: string;
        /**
          * A boolean indicating whether the room is in the process of being checked in. If true, additional actions like saving the room state as "checked in" are performed.
         */
        "checkIn"?: boolean;
        /**
          * A list of available countries. Used to populate dropdowns for selecting the {locales.entries.Lcz_Nationality} of guests.
         */
        "countries"?: ICountry[];
        /**
          * A unique identifier for the room. This is used to distinguish between rooms, especially when performing operations like saving or checking in guests.
         */
        "identifier"?: string;
        /**
          * The language used for displaying text content in the component. Defaults to English ('en'), but can be set to other supported languages.
         */
        "language"?: string;
        "onCloseModal"?: (event: IrRoomGuestsCustomEvent<null>) => void;
        "onResetBookingEvt"?: (event: IrRoomGuestsCustomEvent<null>) => void;
        "onUpdateRoomGuests"?: (event: IrRoomGuestsCustomEvent<{ identifier: string; guests: SharedPerson[] }>) => void;
        /**
          * The name of the room currently being displayed. Used to label the room in the user interface for clarity.
         */
        "roomName"?: string;
        /**
          * An array of people sharing the room. Contains information about the {locales.entries.Lcz_MainGuest} and additional guests, such as their name, date of birth, {locales.entries.Lcz_Nationality}, and ID details.
         */
        "sharedPersons"?: SharedPerson[];
        /**
          * The total number of guests for the room. Determines how many guest input forms to display in the UI.
         */
        "totalGuests"?: number;
    }
    interface IrRoomNights {
        "bookingNumber"?: string;
        "defaultDates"?: { from_date: string; to_date: string };
        "fromDate"?: string;
        "identifier"?: string;
        "language"?: string;
        "onCloseRoomNightsDialog"?: (event: IrRoomNightsCustomEvent<IRoomNightsDataEventPayload>) => void;
        "pool"?: string;
        "propertyId"?: number;
        "ticket"?: string;
        "toDate"?: string;
    }
    interface IrSalesByCountry {
        "language"?: string;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
    }
    interface IrSalesFilters {
        "isLoading"?: boolean;
        "onApplyFilters"?: (event: IrSalesFiltersCustomEvent<SalesFilters>) => void;
    }
    interface IrSalesTable {
        "records"?: SalesRecord[];
    }
    interface IrSecureTasks {
        "bookingNumber"?: string;
        "p"?: string;
        "propertyid"?: number;
    }
    interface IrSelect {
        "LabelAvailable"?: boolean;
        "data"?: selectOption[];
        "disabled"?: boolean;
        "error"?: boolean;
        "firstOption"?: string;
        "label"?: string;
        "labelBackground"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | null;
        "labelBorder"?: 'theme' | 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark' | 'none';
        "labelColor"?: 'primary' | 'secondary' | 'success' | 'danger' | 'warning' | 'info' | 'light' | 'dark';
        "labelPosition"?: 'left' | 'right' | 'center';
        "labelWidth"?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
        "name"?: string;
        "onSelectChange"?: (event: IrSelectCustomEvent<any>) => void;
        "required"?: boolean;
        "selectContainerStyle"?: string;
        "selectForcedStyles"?: { [key: string]: string };
        "selectStyle"?: boolean;
        "selectStyles"?: string;
        "select_id"?: string;
        "selectedValue"?: any;
        "showFirstOption"?: boolean;
        "size"?: 'sm' | 'md' | 'lg';
        "submited"?: boolean;
        "testId"?: string;
        "textSize"?: 'sm' | 'md' | 'lg';
    }
    interface IrSidebar {
        /**
          * Label text displayed in the sidebar header.
         */
        "label"?: string;
        /**
          * Identifier for the sidebar instance.
         */
        "name"?: string;
        /**
          * Event emitted *before* the sidebar attempts to close, but only if `preventClose` is set to true.
         */
        "onBeforeSidebarClose"?: (event: IrSidebarCustomEvent<any>) => void;
        /**
          * Event emitted when the sidebar is toggled open/closed. Emits the current `open` state.
         */
        "onIrSidebarToggle"?: (event: IrSidebarCustomEvent<any>) => void;
        /**
          * Whether the sidebar is open. Can be used with two-way binding.
         */
        "open"?: boolean;
        /**
          * Prevents the sidebar from closing when `toggleSidebar()` is called. When true, emits `beforeSidebarClose` instead of toggling.
         */
        "preventClose"?: boolean;
        /**
          * Whether to show the close (X) button in the sidebar header.
         */
        "showCloseButton"?: boolean;
        /**
          * Which side of the screen the sidebar appears on. Options: `'left'` or `'right'`.
         */
        "side"?: 'right' | 'left';
        /**
          * Inline styles applied to the sidebar container.
         */
        "sidebarStyles"?: Partial<CSSStyleDeclaration>;
    }
    interface IrSpan {
        "text"?: any;
    }
    interface IrSpinner {
        /**
          * Thickness of the spinner's border. Example: `borderWidth={4}` renders a `4px` or `4rem` thick border.
         */
        "borderWidth"?: number;
        /**
          * Color of the spinner. Accepts any valid CSS color string.
         */
        "color"?: string;
        /**
          * Size of the spinner (diameter). Example: `size={2}` with `unit="rem"` sets spinner to `2rem`.
         */
        "size"?: number;
        /**
          * CSS unit used for `size` and `borderWidth`. Can be `'px'` or `'rem'`.
         */
        "unit"?: 'px' | 'rem';
    }
    interface IrSwitch {
        /**
          * Whether the switch is currently checked (on). This is mutable and can be toggled internally.
         */
        "checked"?: boolean;
        /**
          * Disables the switch if true.
         */
        "disabled"?: boolean;
        /**
          * Emitted when the checked state changes. Emits `true` when turned on, `false` when turned off.  Example: ```tsx <ir-switch onCheckChange={(e) => console.log(e.detail)} /> ```
         */
        "onCheckChange"?: (event: IrSwitchCustomEvent<boolean>) => void;
        /**
          * Optional ID for the switch. If not provided, a random ID will be generated.
         */
        "switchId"?: string;
    }
    interface IrTasksFilters {
        "isLoading"?: boolean;
        "onApplyFilters"?: (event: IrTasksFiltersCustomEvent<TaskFilters>) => void;
    }
    interface IrTasksHeader {
        "isCleanedEnabled"?: boolean;
        "onHeaderButtonPress"?: (event: IrTasksHeaderCustomEvent<{ name: 'cleaned' | 'export' | 'archive' }>) => void;
    }
    interface IrTasksTable {
        "onAnimateCleanedButton"?: (event: IrTasksTableCustomEvent<null>) => void;
        "onRowSelectChange"?: (event: IrTasksTableCustomEvent<Task[]>) => void;
        "onSortingChanged"?: (event: IrTasksTableCustomEvent<{ field: string; direction: 'ASC' | 'DESC' }>) => void;
        "tasks"?: Task[];
    }
    interface IrTestCmp {
    }
    interface IrTextEditor {
        "error"?: boolean;
        "maxLength"?: number;
        /**
          * Emits current HTML content whenever it changes
         */
        "onTextChange"?: (event: IrTextEditorCustomEvent<string>) => void;
        /**
          * Placeholder text
         */
        "placeholder"?: string;
        /**
          * If true, makes the editor read-only
         */
        "readOnly"?: boolean;
        /**
          * Type-safe toolbar configuration. For example, you can pass:  {   bold: true,   italic: true,   underline: true,   strike: false,   link: true,   clean: true }
         */
        "toolbarConfig"?: ToolbarConfig;
        /**
          * Determines if the current user can edit the content
         */
        "userCanEdit"?: boolean;
        /**
          * Initial HTML content
         */
        "value"?: string;
    }
    interface IrTextarea {
        /**
          * Number of visible character columns.
         */
        "cols"?: number;
        /**
          * Text label displayed above or beside the textarea.
         */
        "label"?: string;
        /**
          * Width of the label in grid columns (for `variant="prepend"`).
         */
        "labelWidth"?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
        /**
          * Maximum number of characters allowed.
         */
        "maxLength"?: number;
        /**
          * Emits when the textarea content changes.  Example: ```tsx <ir-textarea onTextChange={(e) => console.log(e.detail)} /> ```
         */
        "onTextChange"?: (event: IrTextareaCustomEvent<string>) => void;
        /**
          * Placeholder text shown when input is empty.
         */
        "placeholder"?: string;
        /**
          * Number of visible text lines.
         */
        "rows"?: number;
        /**
          * Inline styles applied directly to the textarea.
         */
        "styles"?: { [key: string]: string };
        /**
          * `data-testid` for targeting in tests.
         */
        "testId"?: string;
        /**
          * Unused property, intended to store textarea text.
         */
        "text"?: string;
        /**
          * Additional classes for the textarea element.
         */
        "textareaClassname"?: string;
        /**
          * Current value of the textarea (supports two-way binding).
         */
        "value"?: string;
        /**
          * Layout style of the textarea: `'default'` shows label above, `'prepend'` shows label on the left.
         */
        "variant"?: 'default' | 'prepend';
    }
    interface IrTitle {
        "borderShown"?: boolean;
        "displayContext"?: 'default' | 'sidebar';
        "justifyContent"?: | 'center'
    | 'start'
    | 'end'
    | 'flex-start'
    | 'flex-end'
    | 'left'
    | 'right'
    | 'normal'
    | 'space-between'
    | 'space-around'
    | 'space-evenly'
    | 'stretch'
    | 'safe center'
    | 'unsafe center';
        "label"?: string;
        "onCloseSideBar"?: (event: IrTitleCustomEvent<null>) => void;
    }
    interface IrToast {
        /**
          * Position where toasts will appear. Options include: `'top-left'`, `'top-right'`, `'bottom-left'`, `'bottom-right'`.
         */
        "position"?: TPositions;
    }
    interface IrTooltip {
        /**
          * Inline styles applied to the outer tooltip container.
         */
        "containerStyle"?: { [key: string]: string };
        /**
          * When true, allows a custom element to trigger the tooltip using a named slot. If false, a default info icon is used.
         */
        "customSlot"?: boolean;
        /**
          * Text or HTML content to be displayed in the tooltip.
         */
        "message"?: string;
        /**
          * Whether the tooltip content should be rendered using `innerHTML`. If false, treats message as plain text.
         */
        "withHtml"?: boolean;
    }
    interface IrUnitStatus {
        "onResetData"?: (event: IrUnitStatusCustomEvent<null>) => void;
    }
    interface IrUserFormPanel {
        "allowedUsersTypes"?: AllowedUser[];
        "baseUserTypeCode"?: string | number;
        "haveAdminPrivileges"?: boolean;
        "isEdit"?: boolean;
        "language"?: string;
        "onCloseSideBar"?: (event: IrUserFormPanelCustomEvent<null>) => void;
        "onResetData"?: (event: IrUserFormPanelCustomEvent<null>) => void;
        "property_id"?: number;
        "superAdminId"?: string;
        "user"?: User;
        "userTypeCode"?: string | number;
        "userTypes"?: { new (entries?: readonly (readonly [string | number, string])[]): Map<string | number, string>; new (iterable?: Iterable<readonly [string | number, string]>): Map<string | number, string>; readonly prototype: Map<any, any>; readonly [Symbol.species]: MapConstructor; };
    }
    interface IrUserManagement {
        "baseUrl"?: string;
        "baseUserTypeCode"?: string | number;
        "isSuperAdmin"?: boolean;
        "language"?: string;
        "p"?: string;
        "propertyid"?: number;
        "ticket"?: string;
        "userId"?: string | number;
        "userTypeCode"?: string | number;
    }
    interface IrUserManagementTable {
        "allowedUsersTypes"?: AllowedUser[];
        "baseUserTypeCode"?: string | number;
        "haveAdminPrivileges"?: boolean;
        "isSuperAdmin"?: boolean;
        "onResetData"?: (event: IrUserManagementTableCustomEvent<null>) => void;
        "onToast"?: (event: IrUserManagementTableCustomEvent<IToast>) => void;
        "property_id"?: number;
        "superAdminId"?: string;
        "userTypeCode"?: string | number;
        "userTypes"?: Map<string | number, string>;
        "users"?: User[];
    }
    interface IrWeekdaySelector {
        /**
          * Emits an updated list of selected weekday values when the selection changes.  Example: ```tsx <ir-weekday-selector onWeekdayChange={(e) => console.log(e.detail)} /> ```
         */
        "onWeekdayChange"?: (event: IrWeekdaySelectorCustomEvent<number[]>) => void;
        /**
          * Initial list of selected weekdays (numeric values).
         */
        "weekdays"?: number[];
    }
    interface OtaLabel {
        /**
          * Label displayed as the section title.
         */
        "label"?: string;
        /**
          * Maximum number of remarks to display before showing the "Show More" button.
         */
        "maxVisibleItems"?: number;
        /**
          * Array of OTA notes to display in the list.
         */
        "remarks"?: IOtaNotes[];
    }
    interface RequirementCheck {
        /**
          * Whether this requirement has been satisfied (true/false).
         */
        "isValid"?: boolean;
        /**
          * The requirement text to display (e.g. "At least one lowercase letter").
         */
        "text"?: string;
    }
    interface IntrinsicElements {
        "igl-application-info": IglApplicationInfo;
        "igl-block-dates-view": IglBlockDatesView;
        "igl-book-property": IglBookProperty;
        "igl-book-property-container": IglBookPropertyContainer;
        "igl-book-property-footer": IglBookPropertyFooter;
        "igl-book-property-header": IglBookPropertyHeader;
        "igl-booking-event": IglBookingEvent;
        "igl-booking-event-hover": IglBookingEventHover;
        "igl-booking-form": IglBookingForm;
        "igl-booking-overview-page": IglBookingOverviewPage;
        "igl-bulk-stop-sale": IglBulkStopSale;
        "igl-cal-body": IglCalBody;
        "igl-cal-footer": IglCalFooter;
        "igl-cal-header": IglCalHeader;
        "igl-date-range": IglDateRange;
        "igl-legends": IglLegends;
        "igl-property-booked-by": IglPropertyBookedBy;
        "igl-rate-plan": IglRatePlan;
        "igl-room-type": IglRoomType;
        "igl-tba-booking-view": IglTbaBookingView;
        "igl-tba-category-view": IglTbaCategoryView;
        "igl-to-be-assigned": IglToBeAssigned;
        "igloo-calendar": IglooCalendar;
        "ir-autocomplete": IrAutocomplete;
        "ir-booking": IrBooking;
        "ir-booking-details": IrBookingDetails;
        "ir-booking-extra-note": IrBookingExtraNote;
        "ir-booking-header": IrBookingHeader;
        "ir-booking-listing": IrBookingListing;
        "ir-booking-printing": IrBookingPrinting;
        "ir-button": IrButton;
        "ir-channel": IrChannel;
        "ir-channel-editor": IrChannelEditor;
        "ir-channel-general": IrChannelGeneral;
        "ir-channel-header": IrChannelHeader;
        "ir-channel-mapping": IrChannelMapping;
        "ir-checkbox": IrCheckbox;
        "ir-checkboxes": IrCheckboxes;
        "ir-combobox": IrCombobox;
        "ir-common": IrCommon;
        "ir-country-picker": IrCountryPicker;
        "ir-date-picker": IrDatePicker;
        "ir-date-range": IrDateRange;
        "ir-date-view": IrDateView;
        "ir-delete-modal": IrDeleteModal;
        "ir-dialog": IrDialog;
        "ir-drawer": IrDrawer;
        "ir-dropdown": IrDropdown;
        "ir-events-log": IrEventsLog;
        "ir-extra-service": IrExtraService;
        "ir-extra-service-config": IrExtraServiceConfig;
        "ir-extra-services": IrExtraServices;
        "ir-guest-info": IrGuestInfo;
        "ir-hk-archive": IrHkArchive;
        "ir-hk-tasks": IrHkTasks;
        "ir-hk-team": IrHkTeam;
        "ir-hk-unassigned-units": IrHkUnassignedUnits;
        "ir-hk-user": IrHkUser;
        "ir-housekeeping": IrHousekeeping;
        "ir-icon": IrIcon;
        "ir-icons": IrIcons;
        "ir-input-text": IrInputText;
        "ir-interactive-title": IrInteractiveTitle;
        "ir-interceptor": IrInterceptor;
        "ir-label": IrLabel;
        "ir-listing-header": IrListingHeader;
        "ir-listing-modal": IrListingModal;
        "ir-loading-screen": IrLoadingScreen;
        "ir-login": IrLogin;
        "ir-modal": IrModal;
        "ir-option-details": IrOptionDetails;
        "ir-ota-service": IrOtaService;
        "ir-ota-services": IrOtaServices;
        "ir-otp": IrOtp;
        "ir-otp-modal": IrOtpModal;
        "ir-password-validator": IrPasswordValidator;
        "ir-payment-actions": IrPaymentActions;
        "ir-payment-details": IrPaymentDetails;
        "ir-payment-option": IrPaymentOption;
        "ir-phone-input": IrPhoneInput;
        "ir-pickup": IrPickup;
        "ir-pickup-view": IrPickupView;
        "ir-pms-logs": IrPmsLogs;
        "ir-popover": IrPopover;
        "ir-price-input": IrPriceInput;
        "ir-radio": IrRadio;
        "ir-range-picker": IrRangePicker;
        "ir-reservation-information": IrReservationInformation;
        "ir-reset-password": IrResetPassword;
        "ir-room": IrRoom;
        "ir-room-guests": IrRoomGuests;
        "ir-room-nights": IrRoomNights;
        "ir-sales-by-country": IrSalesByCountry;
        "ir-sales-filters": IrSalesFilters;
        "ir-sales-table": IrSalesTable;
        "ir-secure-tasks": IrSecureTasks;
        "ir-select": IrSelect;
        "ir-sidebar": IrSidebar;
        "ir-span": IrSpan;
        "ir-spinner": IrSpinner;
        "ir-switch": IrSwitch;
        "ir-tasks-filters": IrTasksFilters;
        "ir-tasks-header": IrTasksHeader;
        "ir-tasks-table": IrTasksTable;
        "ir-test-cmp": IrTestCmp;
        "ir-text-editor": IrTextEditor;
        "ir-textarea": IrTextarea;
        "ir-title": IrTitle;
        "ir-toast": IrToast;
        "ir-tooltip": IrTooltip;
        "ir-unit-status": IrUnitStatus;
        "ir-user-form-panel": IrUserFormPanel;
        "ir-user-management": IrUserManagement;
        "ir-user-management-table": IrUserManagementTable;
        "ir-weekday-selector": IrWeekdaySelector;
        "ota-label": OtaLabel;
        "requirement-check": RequirementCheck;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "igl-application-info": LocalJSX.IglApplicationInfo & JSXBase.HTMLAttributes<HTMLIglApplicationInfoElement>;
            "igl-block-dates-view": LocalJSX.IglBlockDatesView & JSXBase.HTMLAttributes<HTMLIglBlockDatesViewElement>;
            "igl-book-property": LocalJSX.IglBookProperty & JSXBase.HTMLAttributes<HTMLIglBookPropertyElement>;
            "igl-book-property-container": LocalJSX.IglBookPropertyContainer & JSXBase.HTMLAttributes<HTMLIglBookPropertyContainerElement>;
            "igl-book-property-footer": LocalJSX.IglBookPropertyFooter & JSXBase.HTMLAttributes<HTMLIglBookPropertyFooterElement>;
            "igl-book-property-header": LocalJSX.IglBookPropertyHeader & JSXBase.HTMLAttributes<HTMLIglBookPropertyHeaderElement>;
            "igl-booking-event": LocalJSX.IglBookingEvent & JSXBase.HTMLAttributes<HTMLIglBookingEventElement>;
            "igl-booking-event-hover": LocalJSX.IglBookingEventHover & JSXBase.HTMLAttributes<HTMLIglBookingEventHoverElement>;
            "igl-booking-form": LocalJSX.IglBookingForm & JSXBase.HTMLAttributes<HTMLIglBookingFormElement>;
            "igl-booking-overview-page": LocalJSX.IglBookingOverviewPage & JSXBase.HTMLAttributes<HTMLIglBookingOverviewPageElement>;
            "igl-bulk-stop-sale": LocalJSX.IglBulkStopSale & JSXBase.HTMLAttributes<HTMLIglBulkStopSaleElement>;
            "igl-cal-body": LocalJSX.IglCalBody & JSXBase.HTMLAttributes<HTMLIglCalBodyElement>;
            "igl-cal-footer": LocalJSX.IglCalFooter & JSXBase.HTMLAttributes<HTMLIglCalFooterElement>;
            "igl-cal-header": LocalJSX.IglCalHeader & JSXBase.HTMLAttributes<HTMLIglCalHeaderElement>;
            "igl-date-range": LocalJSX.IglDateRange & JSXBase.HTMLAttributes<HTMLIglDateRangeElement>;
            "igl-legends": LocalJSX.IglLegends & JSXBase.HTMLAttributes<HTMLIglLegendsElement>;
            "igl-property-booked-by": LocalJSX.IglPropertyBookedBy & JSXBase.HTMLAttributes<HTMLIglPropertyBookedByElement>;
            "igl-rate-plan": LocalJSX.IglRatePlan & JSXBase.HTMLAttributes<HTMLIglRatePlanElement>;
            "igl-room-type": LocalJSX.IglRoomType & JSXBase.HTMLAttributes<HTMLIglRoomTypeElement>;
            "igl-tba-booking-view": LocalJSX.IglTbaBookingView & JSXBase.HTMLAttributes<HTMLIglTbaBookingViewElement>;
            "igl-tba-category-view": LocalJSX.IglTbaCategoryView & JSXBase.HTMLAttributes<HTMLIglTbaCategoryViewElement>;
            "igl-to-be-assigned": LocalJSX.IglToBeAssigned & JSXBase.HTMLAttributes<HTMLIglToBeAssignedElement>;
            "igloo-calendar": LocalJSX.IglooCalendar & JSXBase.HTMLAttributes<HTMLIglooCalendarElement>;
            "ir-autocomplete": LocalJSX.IrAutocomplete & JSXBase.HTMLAttributes<HTMLIrAutocompleteElement>;
            "ir-booking": LocalJSX.IrBooking & JSXBase.HTMLAttributes<HTMLIrBookingElement>;
            "ir-booking-details": LocalJSX.IrBookingDetails & JSXBase.HTMLAttributes<HTMLIrBookingDetailsElement>;
            "ir-booking-extra-note": LocalJSX.IrBookingExtraNote & JSXBase.HTMLAttributes<HTMLIrBookingExtraNoteElement>;
            "ir-booking-header": LocalJSX.IrBookingHeader & JSXBase.HTMLAttributes<HTMLIrBookingHeaderElement>;
            "ir-booking-listing": LocalJSX.IrBookingListing & JSXBase.HTMLAttributes<HTMLIrBookingListingElement>;
            "ir-booking-printing": LocalJSX.IrBookingPrinting & JSXBase.HTMLAttributes<HTMLIrBookingPrintingElement>;
            "ir-button": LocalJSX.IrButton & JSXBase.HTMLAttributes<HTMLIrButtonElement>;
            "ir-channel": LocalJSX.IrChannel & JSXBase.HTMLAttributes<HTMLIrChannelElement>;
            "ir-channel-editor": LocalJSX.IrChannelEditor & JSXBase.HTMLAttributes<HTMLIrChannelEditorElement>;
            "ir-channel-general": LocalJSX.IrChannelGeneral & JSXBase.HTMLAttributes<HTMLIrChannelGeneralElement>;
            "ir-channel-header": LocalJSX.IrChannelHeader & JSXBase.HTMLAttributes<HTMLIrChannelHeaderElement>;
            "ir-channel-mapping": LocalJSX.IrChannelMapping & JSXBase.HTMLAttributes<HTMLIrChannelMappingElement>;
            "ir-checkbox": LocalJSX.IrCheckbox & JSXBase.HTMLAttributes<HTMLIrCheckboxElement>;
            "ir-checkboxes": LocalJSX.IrCheckboxes & JSXBase.HTMLAttributes<HTMLIrCheckboxesElement>;
            "ir-combobox": LocalJSX.IrCombobox & JSXBase.HTMLAttributes<HTMLIrComboboxElement>;
            "ir-common": LocalJSX.IrCommon & JSXBase.HTMLAttributes<HTMLIrCommonElement>;
            "ir-country-picker": LocalJSX.IrCountryPicker & JSXBase.HTMLAttributes<HTMLIrCountryPickerElement>;
            "ir-date-picker": LocalJSX.IrDatePicker & JSXBase.HTMLAttributes<HTMLIrDatePickerElement>;
            "ir-date-range": LocalJSX.IrDateRange & JSXBase.HTMLAttributes<HTMLIrDateRangeElement>;
            "ir-date-view": LocalJSX.IrDateView & JSXBase.HTMLAttributes<HTMLIrDateViewElement>;
            "ir-delete-modal": LocalJSX.IrDeleteModal & JSXBase.HTMLAttributes<HTMLIrDeleteModalElement>;
            "ir-dialog": LocalJSX.IrDialog & JSXBase.HTMLAttributes<HTMLIrDialogElement>;
            "ir-drawer": LocalJSX.IrDrawer & JSXBase.HTMLAttributes<HTMLIrDrawerElement>;
            "ir-dropdown": LocalJSX.IrDropdown & JSXBase.HTMLAttributes<HTMLIrDropdownElement>;
            "ir-events-log": LocalJSX.IrEventsLog & JSXBase.HTMLAttributes<HTMLIrEventsLogElement>;
            "ir-extra-service": LocalJSX.IrExtraService & JSXBase.HTMLAttributes<HTMLIrExtraServiceElement>;
            "ir-extra-service-config": LocalJSX.IrExtraServiceConfig & JSXBase.HTMLAttributes<HTMLIrExtraServiceConfigElement>;
            "ir-extra-services": LocalJSX.IrExtraServices & JSXBase.HTMLAttributes<HTMLIrExtraServicesElement>;
            "ir-guest-info": LocalJSX.IrGuestInfo & JSXBase.HTMLAttributes<HTMLIrGuestInfoElement>;
            "ir-hk-archive": LocalJSX.IrHkArchive & JSXBase.HTMLAttributes<HTMLIrHkArchiveElement>;
            "ir-hk-tasks": LocalJSX.IrHkTasks & JSXBase.HTMLAttributes<HTMLIrHkTasksElement>;
            "ir-hk-team": LocalJSX.IrHkTeam & JSXBase.HTMLAttributes<HTMLIrHkTeamElement>;
            "ir-hk-unassigned-units": LocalJSX.IrHkUnassignedUnits & JSXBase.HTMLAttributes<HTMLIrHkUnassignedUnitsElement>;
            "ir-hk-user": LocalJSX.IrHkUser & JSXBase.HTMLAttributes<HTMLIrHkUserElement>;
            "ir-housekeeping": LocalJSX.IrHousekeeping & JSXBase.HTMLAttributes<HTMLIrHousekeepingElement>;
            "ir-icon": LocalJSX.IrIcon & JSXBase.HTMLAttributes<HTMLIrIconElement>;
            "ir-icons": LocalJSX.IrIcons & JSXBase.HTMLAttributes<HTMLIrIconsElement>;
            "ir-input-text": LocalJSX.IrInputText & JSXBase.HTMLAttributes<HTMLIrInputTextElement>;
            "ir-interactive-title": LocalJSX.IrInteractiveTitle & JSXBase.HTMLAttributes<HTMLIrInteractiveTitleElement>;
            "ir-interceptor": LocalJSX.IrInterceptor & JSXBase.HTMLAttributes<HTMLIrInterceptorElement>;
            "ir-label": LocalJSX.IrLabel & JSXBase.HTMLAttributes<HTMLIrLabelElement>;
            "ir-listing-header": LocalJSX.IrListingHeader & JSXBase.HTMLAttributes<HTMLIrListingHeaderElement>;
            "ir-listing-modal": LocalJSX.IrListingModal & JSXBase.HTMLAttributes<HTMLIrListingModalElement>;
            "ir-loading-screen": LocalJSX.IrLoadingScreen & JSXBase.HTMLAttributes<HTMLIrLoadingScreenElement>;
            "ir-login": LocalJSX.IrLogin & JSXBase.HTMLAttributes<HTMLIrLoginElement>;
            "ir-modal": LocalJSX.IrModal & JSXBase.HTMLAttributes<HTMLIrModalElement>;
            "ir-option-details": LocalJSX.IrOptionDetails & JSXBase.HTMLAttributes<HTMLIrOptionDetailsElement>;
            "ir-ota-service": LocalJSX.IrOtaService & JSXBase.HTMLAttributes<HTMLIrOtaServiceElement>;
            "ir-ota-services": LocalJSX.IrOtaServices & JSXBase.HTMLAttributes<HTMLIrOtaServicesElement>;
            "ir-otp": LocalJSX.IrOtp & JSXBase.HTMLAttributes<HTMLIrOtpElement>;
            "ir-otp-modal": LocalJSX.IrOtpModal & JSXBase.HTMLAttributes<HTMLIrOtpModalElement>;
            "ir-password-validator": LocalJSX.IrPasswordValidator & JSXBase.HTMLAttributes<HTMLIrPasswordValidatorElement>;
            "ir-payment-actions": LocalJSX.IrPaymentActions & JSXBase.HTMLAttributes<HTMLIrPaymentActionsElement>;
            "ir-payment-details": LocalJSX.IrPaymentDetails & JSXBase.HTMLAttributes<HTMLIrPaymentDetailsElement>;
            "ir-payment-option": LocalJSX.IrPaymentOption & JSXBase.HTMLAttributes<HTMLIrPaymentOptionElement>;
            "ir-phone-input": LocalJSX.IrPhoneInput & JSXBase.HTMLAttributes<HTMLIrPhoneInputElement>;
            "ir-pickup": LocalJSX.IrPickup & JSXBase.HTMLAttributes<HTMLIrPickupElement>;
            "ir-pickup-view": LocalJSX.IrPickupView & JSXBase.HTMLAttributes<HTMLIrPickupViewElement>;
            "ir-pms-logs": LocalJSX.IrPmsLogs & JSXBase.HTMLAttributes<HTMLIrPmsLogsElement>;
            "ir-popover": LocalJSX.IrPopover & JSXBase.HTMLAttributes<HTMLIrPopoverElement>;
            "ir-price-input": LocalJSX.IrPriceInput & JSXBase.HTMLAttributes<HTMLIrPriceInputElement>;
            "ir-radio": LocalJSX.IrRadio & JSXBase.HTMLAttributes<HTMLIrRadioElement>;
            "ir-range-picker": LocalJSX.IrRangePicker & JSXBase.HTMLAttributes<HTMLIrRangePickerElement>;
            "ir-reservation-information": LocalJSX.IrReservationInformation & JSXBase.HTMLAttributes<HTMLIrReservationInformationElement>;
            "ir-reset-password": LocalJSX.IrResetPassword & JSXBase.HTMLAttributes<HTMLIrResetPasswordElement>;
            "ir-room": LocalJSX.IrRoom & JSXBase.HTMLAttributes<HTMLIrRoomElement>;
            "ir-room-guests": LocalJSX.IrRoomGuests & JSXBase.HTMLAttributes<HTMLIrRoomGuestsElement>;
            "ir-room-nights": LocalJSX.IrRoomNights & JSXBase.HTMLAttributes<HTMLIrRoomNightsElement>;
            "ir-sales-by-country": LocalJSX.IrSalesByCountry & JSXBase.HTMLAttributes<HTMLIrSalesByCountryElement>;
            "ir-sales-filters": LocalJSX.IrSalesFilters & JSXBase.HTMLAttributes<HTMLIrSalesFiltersElement>;
            "ir-sales-table": LocalJSX.IrSalesTable & JSXBase.HTMLAttributes<HTMLIrSalesTableElement>;
            "ir-secure-tasks": LocalJSX.IrSecureTasks & JSXBase.HTMLAttributes<HTMLIrSecureTasksElement>;
            "ir-select": LocalJSX.IrSelect & JSXBase.HTMLAttributes<HTMLIrSelectElement>;
            "ir-sidebar": LocalJSX.IrSidebar & JSXBase.HTMLAttributes<HTMLIrSidebarElement>;
            "ir-span": LocalJSX.IrSpan & JSXBase.HTMLAttributes<HTMLIrSpanElement>;
            "ir-spinner": LocalJSX.IrSpinner & JSXBase.HTMLAttributes<HTMLIrSpinnerElement>;
            "ir-switch": LocalJSX.IrSwitch & JSXBase.HTMLAttributes<HTMLIrSwitchElement>;
            "ir-tasks-filters": LocalJSX.IrTasksFilters & JSXBase.HTMLAttributes<HTMLIrTasksFiltersElement>;
            "ir-tasks-header": LocalJSX.IrTasksHeader & JSXBase.HTMLAttributes<HTMLIrTasksHeaderElement>;
            "ir-tasks-table": LocalJSX.IrTasksTable & JSXBase.HTMLAttributes<HTMLIrTasksTableElement>;
            "ir-test-cmp": LocalJSX.IrTestCmp & JSXBase.HTMLAttributes<HTMLIrTestCmpElement>;
            "ir-text-editor": LocalJSX.IrTextEditor & JSXBase.HTMLAttributes<HTMLIrTextEditorElement>;
            "ir-textarea": LocalJSX.IrTextarea & JSXBase.HTMLAttributes<HTMLIrTextareaElement>;
            "ir-title": LocalJSX.IrTitle & JSXBase.HTMLAttributes<HTMLIrTitleElement>;
            "ir-toast": LocalJSX.IrToast & JSXBase.HTMLAttributes<HTMLIrToastElement>;
            "ir-tooltip": LocalJSX.IrTooltip & JSXBase.HTMLAttributes<HTMLIrTooltipElement>;
            "ir-unit-status": LocalJSX.IrUnitStatus & JSXBase.HTMLAttributes<HTMLIrUnitStatusElement>;
            "ir-user-form-panel": LocalJSX.IrUserFormPanel & JSXBase.HTMLAttributes<HTMLIrUserFormPanelElement>;
            "ir-user-management": LocalJSX.IrUserManagement & JSXBase.HTMLAttributes<HTMLIrUserManagementElement>;
            "ir-user-management-table": LocalJSX.IrUserManagementTable & JSXBase.HTMLAttributes<HTMLIrUserManagementTableElement>;
            "ir-weekday-selector": LocalJSX.IrWeekdaySelector & JSXBase.HTMLAttributes<HTMLIrWeekdaySelectorElement>;
            "ota-label": LocalJSX.OtaLabel & JSXBase.HTMLAttributes<HTMLOtaLabelElement>;
            "requirement-check": LocalJSX.RequirementCheck & JSXBase.HTMLAttributes<HTMLRequirementCheckElement>;
        }
    }
}
